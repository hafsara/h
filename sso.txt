Vous avez raison, je vois plusieurs problèmes dans le code que j'ai proposé. Voici les corrections :

## 1. Supprimer la redirection vers '/login'

Corrigeons le `CallbackComponent` :

```typescript
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { OAuthService } from 'angular-oauth2-oidc';

@Component({
  template: `
    <div class="callback-container">
      <p>Traitement de l'authentification...</p>
      <div *ngIf="error" class="error">
        Erreur: {{ error }}
        <button (click)="retry()">Réessayer</button>
      </div>
    </div>
  `
})
export class CallbackComponent implements OnInit {
  error: string = '';

  constructor(
    private oauthService: OAuthService,
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  async ngOnInit() {
    await this.handleAuthentication();
  }

  async handleAuthentication() {
    try {
      // Traiter la réponse OAuth
      await this.oauthService.tryLogin();

      if (this.oauthService.hasValidAccessToken()) {
        // Charger le profil utilisateur
        await this.authService.loadUserProfile();

        // Récupérer l'URL originale ou utiliser une URL par défaut
        const returnUrl = this.getReturnUrl();
        this.router.navigateByUrl(returnUrl);
      } else {
        this.error = 'Échec de l\'authentification - Aucun token valide';
        console.error('Token invalide après authentification');
      }
    } catch (error) {
      console.error('Erreur dans le callback:', error);
      this.error = error.message || 'Erreur lors de l\'authentification';
    }
  }

  private getReturnUrl(): string {
    // Essayer de récupérer l'URL depuis le state OAuth
    const state = this.oauthService.state;
    if (state && state !== '') {
      return state;
    }

    // Essayer depuis les query params
    const returnUrl = this.route.snapshot.queryParams['state'] ||
                     this.route.snapshot.queryParams['returnUrl'];

    // URL par défaut si rien n'est trouvé
    return returnUrl || '/';
  }

  retry() {
    this.error = '';
    this.handleAuthentication();
  }
}
```

## 2. Explication du CallbackComponent

Le `CallbackComponent` est crucial car :
- C'est la page vers laquelle Apigee redirige après l'authentification
- Il récupère le code d'autorisation depuis l'URL
- Il échange ce code contre un token d'accès
- Il redirige vers l'URL originale

## 3. Correction du AuthGuard pour gérer les URLs

```typescript
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<boolean> {
    return new Promise((resolve) => {
      if (this.authService.isLoggedIn) {
        resolve(true);
      } else {
        // Stocker l'URL courante et lancer l'authentification
        const returnUrl = state.url; // ex: /form-view/c73a475d-1742-43d6-901a-c21ad8ca4b7c

        // Lancer le flux OAuth avec l'URL de retour
        this.authService.initLoginFlow(returnUrl);
        resolve(false);
      }
    });
  }
}
```

## 4. Service AuthService corrigé

```typescript
@Injectable({ providedIn: 'root' })
export class AuthService {
  private userProfileSubject = new BehaviorSubject<any>(null);
  public userProfile$ = this.userProfileSubject.asObservable();

  constructor(
    private oauthService: OAuthService,
    private router: Router
  ) {
    this.configure();
  }

  private configure() {
    this.oauthService.configure(authConfig);

    this.oauthService.events.subscribe((event: OAuthEvent) => {
      if (event.type === 'token_received') {
        console.log('Token reçu');
        this.loadUserProfile();
      }
    });

    // Vérifier au démarrage si on a déjà un token valide
    this.tryLogin();
  }

  public tryLogin(): Promise<void> {
    return this.oauthService.tryLogin().then(() => {
      if (this.oauthService.hasValidAccessToken()) {
        console.log('Token valide trouvé au démarrage');
        this.loadUserProfile();
        return Promise.resolve();
      }
    });
  }

  public initLoginFlow(returnUrl?: string): void {
    // Si une URL de retour est spécifiée, elle sera passée dans le state
    this.oauthService.initLoginFlow(returnUrl);
  }

  public loadUserProfile(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.oauthService.hasValidAccessToken()) {
        if (authConfig.userinfoEndpoint) {
          this.oauthService.loadUserProfile().then(profile => {
            this.userProfileSubject.next(profile);
            resolve();
          }).catch(error => {
            console.warn('Impossible de charger le profil:', error);
            this.createBasicProfileFromToken();
            resolve();
          });
        } else {
          this.createBasicProfileFromToken();
          resolve();
        }
      } else {
        reject(new Error('No valid access token'));
      }
    });
  }

  private createBasicProfileFromToken(): void {
    const claims = this.oauthService.getIdentityClaims();
    if (claims) {
      this.userProfileSubject.next(claims);
    } else {
      const token = this.oauthService.getAccessToken();
      if (token) {
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          this.userProfileSubject.next({
            sub: payload.sub,
            name: payload.name,
            email: payload.email,
            // autres claims
          });
        } catch (e) {
          console.warn('Impossible de parser le token:', e);
        }
      }
    }
  }

  public logout(): void {
    this.oauthService.logOut();
    this.userProfileSubject.next(null);
    // Rediriger vers la page d'accueil ou une autre page après logout
    this.router.navigate(['/']);
  }

  public get isLoggedIn(): boolean {
    return this.oauthService.hasValidAccessToken();
  }

  public get accessToken(): string {
    return this.oauthService.getAccessToken();
  }
}
```

## 5. Configuration des routes

```typescript
const routes: Routes = [
  {
    path: 'callback',
    component: CallbackComponent
  },
  {
    path: 'form-view/:id',
    component: FormViewComponent,  // Votre composant
    canActivate: [AuthGuard]       // Protégé par AuthGuard
  },
  // ... autres routes
  {
    path: '**',
    redirectTo: '/'
  }
];
```

## 6. AppComponent simplifié

```typescript
@Component({
  selector: 'app-root',
  template: `<router-outlet></router-outlet>`
})
export class AppComponent {
  // Pas besoin d'appeler tryLogin() ici car le CallbackComponent s'en charge
  // et le AuthGuard gère la protection des routes
}
```

## 7. Diagnostic du problème d'authentification

Si vous avez l'erreur "échec d'authentification" mais que vous êtes authentifié, vérifiez :

### Dans la console du navigateur :
```typescript
// Ajoutez ce debug dans auth.service.ts
console.log('Token valide?', this.oauthService.hasValidAccessToken());
console.log('Access Token:', this.oauthService.getAccessToken());
console.log('Identity Claims:', this.oauthService.getIdentityClaims());
```

### Vérifiez la configuration Apigee :
- L'URL de callback dans Apigee correspond à `http://localhost:4200/callback`
- Le client ID est correct
- Les scopes sont bien configurés

Cette version corrigée devrait résoudre vos problèmes de redirection et gérer correctement vos URLs comme `/form-view/c73a475d-1742-43d6-901a-c21ad8ca4b7c`.
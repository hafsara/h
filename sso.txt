Excellent Hafsa üëè
Puisque tu as d√©j√† **build√© Redis 8.2.2** (serveur + cli) ‚Äî parfait üëå
On va simplement automatiser **le d√©ploiement Sentinel haute disponibilit√© (3 n≈ìuds)** avec **Ansible**, sans utiliser les packages syst√®me.

---

## üéØ Objectif

D√©ployer une architecture **Redis Sentinel 8.2.2 HA** sur **3 serveurs** :

| Serveur  | R√¥le Redis | R√¥le Sentinel |
| -------- | ---------- | ------------- |
| **srv1** | Master     | Sentinel      |
| **srv2** | Replica    | Sentinel      |
| **srv3** | Replica    | Sentinel      |

Les sentinels vont surveiller un master nomm√© `mymaster` avec mot de passe `S3cur3P@ss`.

---

## üóÇÔ∏è Structure du playbook

```
ansible/
‚îú‚îÄ‚îÄ inventory.ini
‚îú‚îÄ‚îÄ deploy_redis_sentinel.yml
‚îî‚îÄ‚îÄ roles/
    ‚îî‚îÄ‚îÄ redis_sentinel/
        ‚îú‚îÄ‚îÄ tasks/
        ‚îÇ   ‚îî‚îÄ‚îÄ main.yml
        ‚îú‚îÄ‚îÄ templates/
        ‚îÇ   ‚îú‚îÄ‚îÄ redis.conf.j2
        ‚îÇ   ‚îî‚îÄ‚îÄ sentinel.conf.j2
        ‚îî‚îÄ‚îÄ files/
            ‚îú‚îÄ‚îÄ redis-server
            ‚îî‚îÄ‚îÄ redis-cli
```

---

## üìã 1. **inventory.ini**

```ini
[redis_sentinel]
srv1 ansible_host=10.0.0.1 redis_role=master
srv2 ansible_host=10.0.0.2 redis_role=replica
srv3 ansible_host=10.0.0.3 redis_role=replica
```

---

## üìã 2. **deploy_redis_sentinel.yml**

```yaml
---
- name: Deploy Redis 8.2.2 Sentinel Cluster
  hosts: redis_sentinel
  become: yes
  vars:
    redis_version: "8.2.2"
    redis_install_dir: "/opt/redis-{{ redis_version }}"
    redis_data_dir: "/var/lib/redis"
    redis_log_dir: "/var/log/redis"
    redis_conf_dir: "/etc/redis"
    redis_user: "redis"
    redis_port: 6379
    sentinel_port: 26379
    redis_password: "S3cur3P@ss"
    redis_master_name: "mymaster"
    redis_master_host: "10.0.0.1"

  roles:
    - redis_sentinel
```

---

## üìã 3. **roles/redis_sentinel/tasks/main.yml**

```yaml
---
- name: Ensure Redis user exists
  ansible.builtin.user:
    name: "{{ redis_user }}"
    shell: /sbin/nologin
    system: yes

- name: Create directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ redis_user }}"
    group: "{{ redis_user }}"
    mode: "0755"
  loop:
    - "{{ redis_data_dir }}"
    - "{{ redis_log_dir }}"
    - "{{ redis_conf_dir }}"

- name: Copy redis-server and redis-cli binaries
  ansible.builtin.copy:
    src: "{{ item }}"
    dest: "/usr/local/bin/{{ item }}"
    owner: root
    group: root
    mode: "0755"
  loop:
    - redis-server
    - redis-cli

- name: Generate redis.conf
  ansible.builtin.template:
    src: "redis.conf.j2"
    dest: "{{ redis_conf_dir }}/redis.conf"
    owner: "{{ redis_user }}"
    group: "{{ redis_user }}"
    mode: "0644"
  notify: Restart Redis

- name: Generate sentinel.conf
  ansible.builtin.template:
    src: "sentinel.conf.j2"
    dest: "{{ redis_conf_dir }}/sentinel.conf"
    owner: "{{ redis_user }}"
    group: "{{ redis_user }}"
    mode: "0644"
  notify: Restart Sentinel

- name: Create systemd service for redis
  ansible.builtin.copy:
    dest: /etc/systemd/system/redis.service
    content: |
      [Unit]
      Description=Redis Server
      After=network.target

      [Service]
      User={{ redis_user }}
      ExecStart=/usr/local/bin/redis-server {{ redis_conf_dir }}/redis.conf
      ExecStop=/usr/local/bin/redis-cli -a {{ redis_password }} shutdown
      Restart=always
      LimitNOFILE=10000

      [Install]
      WantedBy=multi-user.target
  notify: Restart Redis

- name: Create systemd service for sentinel
  ansible.builtin.copy:
    dest: /etc/systemd/system/redis-sentinel.service
    content: |
      [Unit]
      Description=Redis Sentinel
      After=network.target redis.service

      [Service]
      User={{ redis_user }}
      ExecStart=/usr/local/bin/redis-sentinel {{ redis_conf_dir }}/sentinel.conf --daemonize no
      Restart=always
      LimitNOFILE=10000

      [Install]
      WantedBy=multi-user.target
  notify: Restart Sentinel

- name: Enable and start services
  ansible.builtin.systemd:
    name: "{{ item }}"
    enabled: yes
    state: started
  loop:
    - redis
    - redis-sentinel

# Handlers
- name: Restart Redis
  ansible.builtin.systemd:
    name: redis
    state: restarted
    daemon_reload: yes

- name: Restart Sentinel
  ansible.builtin.systemd:
    name: redis-sentinel
    state: restarted
    daemon_reload: yes
```

---

## üìã 4. **roles/redis_sentinel/templates/redis.conf.j2**

```jinja
bind 0.0.0.0
port {{ redis_port }}
protected-mode no

dir {{ redis_data_dir }}
logfile {{ redis_log_dir }}/redis.log
dbfilename dump.rdb
appendonly yes

requirepass {{ redis_password }}
masterauth {{ redis_password }}

{% if redis_role == "replica" %}
replicaof {{ redis_master_host }} {{ redis_port }}
{% endif %}

timeout 0
tcp-keepalive 60
```

---

## üìã 5. **roles/redis_sentinel/templates/sentinel.conf.j2**

```jinja
port {{ sentinel_port }}
bind 0.0.0.0
protected-mode no
daemonize no
dir /tmp
logfile {{ redis_log_dir }}/sentinel.log

sentinel monitor {{ redis_master_name }} {{ redis_master_host }} {{ redis_port }} 2
sentinel auth-pass {{ redis_master_name }} {{ redis_password }}
sentinel down-after-milliseconds {{ redis_master_name }} 5000
sentinel failover-timeout {{ redis_master_name }} 10000
sentinel parallel-syncs {{ redis_master_name }} 1
```

---

## üöÄ 6. **D√©ploiement**

> ‚öôÔ∏è Assure-toi d‚Äôavoir ton `redis-server` et `redis-cli` d√©j√† compil√©s dans `roles/redis_sentinel/files/`.

Puis lance :

```bash
ansible-playbook -i inventory.ini deploy_redis_sentinel.yml
```

---

## ‚úÖ 7. **V√©rifications post-d√©ploiement**

Sur n‚Äôimporte quel n≈ìud :

```bash
redis-cli -a S3cur3P@ss info replication
```

Tu dois voir :

```
role:master
connected_slaves:2
```

Et c√¥t√© Sentinel :

```bash
redis-cli -p 26379 SENTINEL get-master-addr-by-name mymaster
```

Tu verras :

```
1) "10.0.0.1"
2) "6379"
```

---

## üß† Bonus : Test de failover

Simule un crash du master :

```bash
sudo systemctl stop redis
sleep 10
redis-cli -p 26379 SENTINEL get-master-addr-by-name mymaster
```

Le nouveau master sera automatiquement **srv2** ou **srv3** üîÅ

---

Souhaites-tu que je te g√©n√®re la **version avec failover monitoring via Prometheus exporter** (pour voir les bascules en live) ?
üëâ C‚Äôest souvent tr√®s utile en prod (et je peux te l‚Äôint√©grer au m√™me playbook).



















Voici le code du `RedisManager` adapt√© sp√©cifiquement pour **Redis Sentinel** :

## üî• **RedisManager pour Redis Sentinel**

```python
# workflow/redis_manager.py
import redis
from redis.sentinel import Sentinel
from datetime import timedelta, datetime
import logging
import uuid
import time
from contextlib import contextmanager
from typing import Optional, List, Dict, Any, Union
import socket

logger = logging.getLogger(__name__)

class RedisManager:
    """
    Manager Redis optimis√© pour Redis Sentinel
    Supporte la haute disponibilit√© avec failover automatique
    """

    def __init__(self, config):
        self.config = config
        self._sentinel = None
        self._master_client = None
        self._slave_client = None
        self._service_name = getattr(config, 'REDIS_SENTINEL_SERVICE_NAME', 'mymaster')
        self._sentinel_hosts = getattr(config, 'REDIS_SENTINEL_HOSTS', [])
        self._password = getattr(config, 'REDIS_PASSWORD', None)
        self._socket_timeout = getattr(config, 'REDIS_SOCKET_TIMEOUT', 5)

    @property
    def sentinel(self):
        """Client Sentinel lazy-loaded"""
        if self._sentinel is None:
            self._sentinel = self._create_sentinel()
        return self._sentinel

    @property
    def master(self):
        """Client Redis master lazy-loaded"""
        if self._master_client is None:
            self._master_client = self._get_master_client()
        return self._master_client

    @property
    def slave(self):
        """Client Redis slave lazy-loaded (pour les lectures)"""
        if self._slave_client is None:
            self._slave_client = self._get_slave_client()
        return self._slave_client

    def _create_sentinel(self) -> Sentinel:
        """Cr√©e le client Sentinel"""
        try:
            logger.info(f"Initializing Redis Sentinel with hosts: {self._sentinel_hosts}")

            sentinel = Sentinel(
                self._sentinel_hosts,
                socket_timeout=self._socket_timeout,
                password=self._password,
                decode_responses=True,
                retry_on_timeout=True,
                sentinel_kwargs={
                    'password': self._password,
                    'socket_timeout': self._socket_timeout
                }
            )

            # Test de connexion
            sentinel.discover_master(self._service_name)
            logger.info("‚úÖ Redis Sentinel initialized successfully")

            return sentinel

        except Exception as e:
            logger.error(f"‚ùå Failed to create Redis Sentinel: {e}")
            raise

    def _get_master_client(self) -> redis.Redis:
        """R√©cup√®re le client Redis master"""
        try:
            master = self.sentinel.master_for(
                self._service_name,
                socket_timeout=self._socket_timeout,
                password=self._password,
                decode_responses=True,
                retry_on_timeout=True
            )

            # Test de connexion
            master.ping()
            logger.info("‚úÖ Redis Master client connected")

            return master

        except Exception as e:
            logger.error(f"‚ùå Failed to connect to Redis Master: {e}")
            raise

    def _get_slave_client(self) -> redis.Redis:
        """R√©cup√®re un client Redis slave (pour lectures)"""
        try:
            slave = self.sentinel.slave_for(
                self._service_name,
                socket_timeout=self._socket_timeout,
                password=self._password,
                decode_responses=True,
                retry_on_timeout=True
            )

            # Test de connexion
            slave.ping()
            logger.info("‚úÖ Redis Slave client connected")

            return slave

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Failed to connect to Redis Slave, falling back to master: {e}")
            return self.master  # Fallback sur master

    def _refresh_connection_if_needed(self):
        """Rafra√Æchit les connexions si n√©cessaire"""
        try:
            self.master.ping()
        except (redis.ConnectionError, redis.ResponseError):
            logger.warning("üîÑ Redis Master connection lost, refreshing...")
            self._master_client = None
            self._slave_client = None

    # üî• OP√âRATIONS DE BASE AVEC SENTINEL
    def setex(self, key: str, ttl: timedelta, value: str) -> bool:
        """SETEX sur le master"""
        try:
            self._refresh_connection_if_needed()
            return self.master.setex(key, int(ttl.total_seconds()), value)
        except Exception as e:
            logger.error(f"Redis SETEX error for key {key}: {e}")
            raise

    def get(self, key: str, use_slave: bool = True) -> Optional[str]:
        """GET - utilise le slave si disponible pour les lectures"""
        try:
            client = self.slave if use_slave else self.master
            return client.get(key)
        except Exception as e:
            logger.error(f"Redis GET error for key {key}: {e}")
            return None

    def keys(self, pattern: str, use_slave: bool = True) -> List[str]:
        """KEYS avec fallback sur SCAN"""
        try:
            client = self.slave if use_slave else self.master

            # Utilise SCAN pour √©viter de bloquer Redis
            keys = []
            cursor = 0
            while True:
                cursor, found_keys = client.scan(
                    cursor=cursor,
                    match=pattern,
                    count=100
                )
                keys.extend(found_keys)
                if cursor == 0:
                    break
            return keys

        except Exception as e:
            logger.error(f"Redis KEYS/SCAN error for pattern {pattern}: {e}")
            return []

    def xadd(self, stream: str, fields: Dict[str, Any], maxlen: Optional[int] = None) -> str:
        """XADD sur le master"""
        try:
            self._refresh_connection_if_needed()

            kwargs = {}
            if maxlen:
                kwargs['maxlen'] = maxlen
                kwargs['approximate'] = True

            return self.master.xadd(stream, fields, **kwargs)
        except Exception as e:
            logger.error(f"Redis XADD error for stream {stream}: {e}")
            raise

    def xread(self, streams: Dict[str, str], count: Optional[int] = None, block: Optional[int] = None) -> Dict:
        """XREAD - peut utiliser le slave pour les lectures"""
        try:
            client = self.slave  # Lectures sur slave si possible

            return client.xread(streams, count=count, block=block)
        except Exception as e:
            logger.error(f"Redis XREAD error for streams {streams}: {e}")
            return {}

    def xdel(self, stream: str, *message_ids: str) -> int:
        """XDEL sur le master"""
        try:
            self._refresh_connection_if_needed()
            return self.master.xdel(stream, *message_ids)
        except Exception as e:
            logger.error(f"Redis XDEL error for stream {stream}: {e}")
            return 0

    def xrange(self, stream: str, start: str = '-', end: str = '+', count: Optional[int] = None) -> List:
        """XRANGE - utilise le slave pour les lectures"""
        try:
            client = self.slave
            return client.xrange(stream, min=start, max=end, count=count)
        except Exception as e:
            logger.error(f"Redis XRANGE error for stream {stream}: {e}")
            return []

    # üî• FONCTIONNALIT√âS AVANC√âES
    def json_set(self, key: str, path: str, obj: Any, ttl: Optional[timedelta] = None) -> bool:
        """JSON.SET sur le master"""
        try:
            self._refresh_connection_if_needed()

            if hasattr(self.master, 'json_set'):
                result = self.master.json_set(key, path, obj)
                if result and ttl:
                    self.master.expire(key, int(ttl.total_seconds()))
                return result
            else:
                # Fallback si JSON non disponible
                import json
                result = self.master.set(key, json.dumps(obj))
                if result and ttl:
                    self.master.expire(key, int(ttl.total_seconds()))
                return result
        except Exception as e:
            logger.error(f"Redis JSON.SET error for key {key}: {e}")
            return False

    def json_get(self, key: str, path: str = '.') -> Optional[Any]:
        """JSON.GET - utilise le slave pour les lectures"""
        try:
            client = self.slave

            if hasattr(client, 'json_get'):
                return client.json_get(key, path)
            else:
                # Fallback
                import json
                data = client.get(key)
                return json.loads(data) if data else None
        except Exception as e:
            logger.error(f"Redis JSON.GET error for key {key}: {e}")
            return None

    # üî• LOCKS DISTRIBU√âS OPTIMIS√âS POUR SENTINEL
    def acquire_lock(self, lock_name: str, timeout: int = 30, acquire_timeout: int = 10) -> Optional[str]:
        """Acquire a distributed lock avec gestion Sentinel"""
        identifier = str(uuid.uuid4())
        lock_key = f"lock:{lock_name}"
        end_time = time.time() + acquire_timeout

        while time.time() < end_time:
            try:
                self._refresh_connection_if_needed()

                if self.master.set(lock_key, identifier, ex=timeout, nx=True):
                    return identifier
                time.sleep(0.1)  # 100ms
            except Exception as e:
                logger.error(f"Redis lock acquisition error for {lock_name}: {e}")
                break

        return None

    def release_lock(self, lock_name: str, identifier: str) -> bool:
        """Release lock seulement si owned par le current process"""
        lock_key = f"lock:{lock_name}"

        lua_script = """
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
        """

        try:
            self._refresh_connection_if_needed()
            release_script = self.master.register_script(lua_script)
            result = release_script(keys=[lock_key], args=[identifier])
            return result == 1
        except Exception as e:
            logger.error(f"Redis lock release error for {lock_name}: {e}")
            return False

    @contextmanager
    def lock(self, lock_name: str, timeout: int = 30, acquire_timeout: int = 10):
        """Context manager pour distributed locks avec Sentinel"""
        identifier = self.acquire_lock(lock_name, timeout, acquire_timeout)
        if not identifier:
            raise Exception(f"Could not acquire lock: {lock_name}")

        try:
            yield identifier
        finally:
            self.release_lock(lock_name, identifier)

    # üî• COORDINATION ET HA AVEC SENTINEL
    def register_server_heartbeat(self, server_id: str, ttl: timedelta = timedelta(seconds=60)) -> bool:
        """Enregistre un heartbeat de serveur sur le master"""
        try:
            self._refresh_connection_if_needed()

            key = f"servers:heartbeats"
            pipeline = self.master.pipeline()
            pipeline.hset(key, server_id, datetime.utcnow().isoformat())
            pipeline.expire(key, int(ttl.total_seconds() * 2))
            pipeline.execute()
            return True
        except Exception as e:
            logger.error(f"Redis heartbeat registration error for server {server_id}: {e}")
            return False

    def get_active_servers(self, max_age: timedelta = timedelta(seconds=45)) -> List[str]:
        """Retourne les serveurs actifs - lecture sur slave"""
        try:
            key = f"servers:heartbeats"
            heartbeats = self.slave.hgetall(key)
            active_servers = []
            current_time = datetime.utcnow()

            for server_id, heartbeat_str in heartbeats.items():
                try:
                    heartbeat_time = datetime.fromisoformat(heartbeat_str)
                    if (current_time - heartbeat_time) < max_age:
                        active_servers.append(server_id)
                except ValueError:
                    continue

            return sorted(active_servers)
        except Exception as e:
            logger.error(f"Redis get active servers error: {e}")
            return []

    def is_server_leader(self, server_id: str) -> bool:
        """D√©termine si le serveur est le leader"""
        active_servers = self.get_active_servers()
        return bool(active_servers) and active_servers[0] == server_id

    # üî• INFORMATIONS SENTINEL
    def get_sentinel_info(self) -> Dict[str, Any]:
        """R√©cup√®re les informations du cluster Sentinel"""
        try:
            master_info = self.sentinel.discover_master(self._service_name)
            slaves_info = self.sentinel.discover_slaves(self._service_name)
            sentinels_info = self.sentinel.sentinels(self._service_name)

            return {
                "master": master_info,
                "slaves": slaves_info,
                "sentinels": sentinels_info,
                "service_name": self._service_name,
                "sentinel_hosts": self._sentinel_hosts
            }
        except Exception as e:
            logger.error(f"Failed to get Sentinel info: {e}")
            return {"error": str(e)}

    def get_master_address(self) -> Optional[tuple]:
        """Retourne l'adresse du master actuel"""
        try:
            return self.sentinel.discover_master(self._service_name)
        except Exception as e:
            logger.error(f"Failed to get master address: {e}")
            return None

    def failover_status(self) -> Dict[str, Any]:
        """Statut du failover Sentinel"""
        try:
            master_addr = self.get_master_address()
            active_servers = self.get_active_servers()

            return {
                "current_master": master_addr,
                "active_servers": active_servers,
                "total_servers": len(active_servers),
                "is_healthy": master_addr is not None,
                "server_id": getattr(self.config, 'SERVER_ID', 'unknown'),
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            return {
                "error": str(e),
                "is_healthy": False,
                "timestamp": datetime.utcnow().isoformat()
            }

    # üî• HEALTH CHECK COMPLET
    def health_check(self) -> Dict[str, Any]:
        """V√©rifie la sant√© compl√®te de Redis Sentinel"""
        try:
            start_time = time.time()

            # Test master
            master_ping = self.master.ping()
            master_info = self.master.info('server')

            # Test slave
            slave_ping = self.slave.ping() if self._slave_client != self._master_client else True

            # Test Sentinel
            sentinel_info = self.get_sentinel_info()

            response_time = (time.time() - start_time) * 1000

            return {
                "status": "healthy",
                "response_time_ms": round(response_time, 2),
                "master": {
                    "ping": master_ping,
                    "version": master_info.get('redis_version', 'unknown'),
                    "role": "master"
                },
                "slave": {
                    "ping": slave_ping,
                    "available": self._slave_client != self._master_client
                },
                "sentinel": {
                    "service_name": self._service_name,
                    "master_address": sentinel_info.get('master'),
                    "slaves_count": len(sentinel_info.get('slaves', [])),
                    "sentinels_count": len(sentinel_info.get('sentinels', []))
                },
                "failover_status": self.failover_status()
            }

        except Exception as e:
            logger.error(f"Redis Sentinel health check failed: {e}")
            return {
                "status": "unhealthy",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }

    # üî• M√âTHODES UTILITAIRES
    def flush_all(self) -> bool:
        """Vide toutes les donn√©es (uniquement en dev)"""
        if getattr(self.config, 'ENV', 'production') == 'production':
            logger.error("üö® FLUSH_ALL called in production! Operation blocked.")
            return False

        try:
            self._refresh_connection_if_needed()
            return self.master.flushall()
        except Exception as e:
            logger.error(f"Redis FLUSHALL error: {e}")
            return False

    def get_memory_info(self) -> Dict[str, Any]:
        """Informations sur l'utilisation m√©moire"""
        try:
            info = self.master.info('memory')
            return {
                "used_memory": info.get('used_memory', 0),
                "used_memory_human": info.get('used_memory_human', '0B'),
                "used_memory_peak": info.get('used_memory_peak', 0),
                "used_memory_peak_human": info.get('used_memory_peak_human', '0B'),
                "memory_fragmentation_ratio": info.get('mem_fragmentation_ratio', 0)
            }
        except Exception as e:
            logger.error(f"Failed to get memory info: {e}")
            return {"error": str(e)}
```

## üõ† **Configuration pour Sentinel**

```python
# config.py
import os
import socket

class Config:
    # Identification serveur
    SERVER_ID = os.getenv('SERVER_ID', socket.gethostname())

    # Redis Sentinel Configuration
    REDIS_SENTINEL_SERVICE_NAME = os.getenv('REDIS_SENTINEL_SERVICE_NAME', 'mymaster')
    REDIS_SENTINEL_HOSTS = [
        (os.getenv('REDIS_SENTINEL_HOST1', 'sentinel1'), int(os.getenv('REDIS_SENTINEL_PORT1', 26379))),
        (os.getenv('REDIS_SENTINEL_HOST2', 'sentinel2'), int(os.getenv('REDIS_SENTINEL_PORT2', 26379))),
        (os.getenv('REDIS_SENTINEL_HOST3', 'sentinel3'), int(os.getenv('REDIS_SENTINEL_PORT3', 26379))),
    ]
    REDIS_PASSWORD = os.getenv('REDIS_PASSWORD')
    REDIS_SOCKET_TIMEOUT = int(os.getenv('REDIS_SOCKET_TIMEOUT', 5))

    # Celery avec Sentinel
    CELERY_BROKER_URL = f"sentinel://:{REDIS_PASSWORD}@{REDIS_SENTINEL_HOSTS[0][0]}:{REDIS_SENTINEL_HOSTS[0][1]}/0"
    CELERY_BROKER_TRANSPORT_OPTIONS = {
        'master_name': REDIS_SENTINEL_SERVICE_NAME,
        'socket_timeout': REDIS_SOCKET_TIMEOUT,
        'retry_on_timeout': True,
        'sentinel_kwargs': {
            'password': REDIS_PASSWORD,
            'socket_timeout': REDIS_SOCKET_TIMEOUT
        }
    }
    CELERY_RESULT_BACKEND = CELERY_BROKER_URL
```

## üê≥ **Docker Compose pour Sentinel**

```yaml
# docker-compose.sentinel.yml
version: '3.8'

services:
  # Redis Master
  redis-master:
    image: redis:7.2-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_master_data:/data
    ports:
      - "6379:6379"
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}

  # Redis Slave
  redis-slave:
    image: redis:7.2-alpine
    command: >
      redis-server
      --appendonly yes
      --requirepass ${REDIS_PASSWORD}
      --replicaof redis-master 6379
      --masterauth ${REDIS_PASSWORD}
    volumes:
      - redis_slave_data:/data
    depends_on:
      - redis-master
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}

  # Sentinels
  redis-sentinel-1:
    image: redis:7.2-alpine
    command: >
      redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./sentinel.conf:/etc/redis/sentinel.conf
    ports:
      - "26379:26379"
    depends_on:
      - redis-master
      - redis-slave

  redis-sentinel-2:
    image: redis:7.2-alpine
    command: >
      redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./sentinel.conf:/etc/redis/sentinel.conf
    ports:
      - "26380:26379"
    depends_on:
      - redis-master
      - redis-slave

  redis-sentinel-3:
    image: redis:7.2-alpine
    command: >
      redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./sentinel.conf:/etc/redis/sentinel.conf
    ports:
      - "26381:26379"
    depends_on:
      - redis-master
      - redis-slave

  # Application
  backend:
    build: .
    environment:
      - SERVER_ID=backend-1
      - REDIS_SENTINEL_SERVICE_NAME=mymaster
      - REDIS_SENTINEL_HOST1=redis-sentinel-1
      - REDIS_SENTINEL_PORT1=26379
      - REDIS_SENTINEL_HOST2=redis-sentinel-2
      - REDIS_SENTINEL_PORT2=26379
      - REDIS_SENTINEL_HOST3=redis-sentinel-3
      - REDIS_SENTINEL_PORT3=26379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    depends_on:
      - redis-sentinel-1
      - redis-sentinel-2
      - redis-sentinel-3

volumes:
  redis_master_data:
  redis_slave_data:
```

## ‚úÖ **AVANTAGES DE CETTE VERSION SENTINEL**

1. **üéØ Haute Disponibilit√©** : Failover automatique
2. **üìà Performance** : Lectures sur slaves, √©critures sur master
3. **üîí Fiabilit√©** : D√©tection automatique des pannes
4. **üöÄ Scalable** : Ajout facile de slaves
5. **üêõ D√©bogable** : Monitoring complet du cluster
6. **üí™ R√©silient** : Reconnexion automatique

Cette version Sentinel est **parfaite pour la production** ! üöÄ
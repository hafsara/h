Voici le code complet pour l'intégration d'Apigee avec Angular en utilisant angular-oauth2-oidc :

## 1. Configuration AuthService

```typescript
import { Injectable } from '@angular/core';
import { OAuthService, AuthConfig } from 'angular-oauth2-oidc';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject, Observable } from 'rxjs';
import { SharedService } from './shared.service';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private authenticated = new BehaviorSubject<boolean>(false);
  public isAuthenticated$ = this.authenticated.asObservable();

  constructor(
    private oauthService: OAuthService,
    private http: HttpClient,
    private sharedService: SharedService
  ) {
    this.configureOAuth();
  }

  private authConfig: AuthConfig = {
    // URL de discovery customisée pour Apigee
    issuer: 'https://your-apigee-domain.com/oauth2',
    loginUrl: 'https://your-apigee-domain.com/oauth2/authorize',
    tokenEndpoint: 'https://your-apigee-domain.com/oauth2/token',
    userinfoEndpoint: 'https://your-apigee-domain.com/oauth2/userinfo',
    redirectUri: window.location.origin + '/callback',
    clientId: 'your-client-id',
    responseType: 'code',
    scope: 'openid profile email',
    showDebugInformation: true, // À désactiver en production
    strictDiscoveryDocumentValidation: false,
    sessionChecksEnabled: true,
    timeoutFactor: 0.75,
    clearHashAfterLogin: true
  };

  private configureOAuth(): void {
    this.oauthService.configure(this.authConfig);
    
    // Configuration pour le refresh token automatique
    this.oauthService.setupAutomaticSilentRefresh();
    
    // Charger la configuration de discovery
    this.oauthService.loadDiscoveryDocument().then(() => {
      console.log('Discovery document loaded');
      
      // Vérifier si l'utilisateur est déjà connecté
      this.oauthService.tryLogin().then(() => {
        if (this.oauthService.hasValidAccessToken()) {
          this.authenticated.next(true);
          this.loadUserInfo();
        }
      });
    }).catch(error => {
      console.error('Error loading discovery document', error);
    });

    // Écouter les événements de token
    this.oauthService.events.subscribe(event => {
      if (event.type === 'token_received') {
        this.authenticated.next(true);
        this.loadUserInfo();
      }
      
      if (event.type === 'token_refreshed') {
        console.log('Token refreshed successfully');
        this.loadUserInfo();
      }
      
      if (event.type === 'token_expires' || event.type === 'session_terminated') {
        this.authenticated.next(false);
      }
    });
  }

  public initLoginFlow(): void {
    this.oauthService.initLoginFlow();
  }

  public login(): void {
    this.oauthService.initLoginFlow();
  }

  public logout(): void {
    this.oauthService.logOut();
    this.authenticated.next(false);
    this.sharedService.clearUserInfo();
  }

  public getToken(): string | null {
    return this.oauthService.getAccessToken();
  }

  public decodeToken(token: string): any {
    try {
      const base64Url = token.split('.')[1];
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));

      return JSON.parse(jsonPayload);
    } catch (error) {
      console.error('Error decoding token', error);
      return null;
    }
  }

  private loadUserInfo(): void {
    this.oauthService.loadUserProfile().then((userInfo: any) => {
      console.log('User info loaded', userInfo);
      
      // Mettre à jour le shared service avec les informations utilisateur
      this.sharedService.setUserInfo({
        uid: userInfo.sub || userInfo.user_id,
        username: userInfo.preferred_username || userInfo.username || userInfo.email,
        email: userInfo.email,
        avatar: userInfo.picture || userInfo.avatar,
        given_name: userInfo.given_name,
        family_name: userInfo.family_name,
        name: userInfo.name,
        // Ajouter d'autres champs selon votre configuration Apigee
      });
    }).catch(error => {
      console.error('Error loading user info', error);
      // Fallback: utiliser les informations du token
      const token = this.getToken();
      if (token) {
        const decodedToken = this.decodeToken(token);
        this.sharedService.setUserInfo({
          uid: decodedToken.sub,
          username: decodedToken.preferred_username || decodedToken.username,
          email: decodedToken.email,
          avatar: decodedToken.picture || decodedToken.avatar,
        });
      }
    });
  }

  public refreshToken(): Promise<void> {
    return this.oauthService.refreshToken().then(() => {
      console.log('Token refreshed successfully');
    }).catch(error => {
      console.error('Error refreshing token', error);
      this.logout();
    });
  }

  public hasValidToken(): boolean {
    return this.oauthService.hasValidAccessToken();
  }

  public getAccessToken(): string {
    return this.oauthService.getAccessToken();
  }

  public getIdentityClaims(): any {
    return this.oauthService.getIdentityClaims();
  }
}
```

## 2. Configuration AppModule

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http';
import { OAuthModule, OAuthStorage } from 'angular-oauth2-oidc';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { AuthService } from './services/auth.service';
import { SharedService } from './services/shared.service';

// Configuration du storage pour OAuth
export function storageFactory(): OAuthStorage {
  return localStorage;
}

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule,
    OAuthModule.forRoot({
      resourceServer: {
        allowedUrls: ['https://your-apigee-domain.com/api'],
        sendAccessToken: true
      }
    })
  ],
  providers: [
    AuthService,
    SharedService,
    { provide: OAuthStorage, useFactory: storageFactory }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## 3. Callback Component

```typescript
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { OAuthService } from 'angular-oauth2-oidc';

@Component({
  selector: 'app-callback',
  template: `
    <div class="callback-container">
      <div class="spinner"></div>
      <p>Connexion en cours...</p>
    </div>
  `,
  styles: [`
    .callback-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 2s linear infinite;
      margin-bottom: 16px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `]
})
export class CallbackComponent implements OnInit {

  constructor(
    private oauthService: OAuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  ngOnInit(): void {
    this.handleCallback();
  }

  private handleCallback(): void {
    this.oauthService.loadDiscoveryDocumentAndTryLogin().then(() => {
      if (this.oauthService.hasValidAccessToken()) {
        // Récupérer l'URL de redirection originale ou aller vers la page d'accueil
        const returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';
        this.router.navigate([returnUrl]);
      } else {
        // Si la connexion a échoué, rediriger vers la page de login
        this.router.navigate(['/auth']);
      }
    }).catch(error => {
      console.error('Error during callback handling', error);
      this.router.navigate(['/auth']);
    });
  }
}
```

## 4. SharedService mis à jour

```typescript
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

export interface UserInfo {
  uid: string;
  username: string;
  email?: string;
  avatar?: string;
  given_name?: string;
  family_name?: string;
  name?: string;
  [key: string]: any;
}

@Injectable({
  providedIn: 'root'
})
export class SharedService {
  private userInfo = new BehaviorSubject<UserInfo | null>(null);
  public userInfo$ = this.userInfo.asObservable();

  constructor() {}

  setUserInfo(info: UserInfo): void {
    this.userInfo.next(info);
    // Optionnel: stocker dans le localStorage pour persistance
    localStorage.setItem('userInfo', JSON.stringify(info));
  }

  getUserInfo(): UserInfo | null {
    return this.userInfo.value;
  }

  clearUserInfo(): void {
    this.userInfo.next(null);
    localStorage.removeItem('userInfo');
  }

  // Récupérer les infos depuis le localStorage au démarrage
  loadStoredUserInfo(): void {
    const stored = localStorage.getItem('userInfo');
    if (stored) {
      try {
        this.userInfo.next(JSON.parse(stored));
      } catch (error) {
        console.error('Error parsing stored user info', error);
        localStorage.removeItem('userInfo');
      }
    }
  }
}
```

## 5. SSO Guard mis à jour

```typescript
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from '../services/auth.service';
import { SharedService } from '../services/shared.service';

export const sSOGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const sharedService = inject(SharedService);
  const router = inject(Router);

  if (authService.hasValidToken()) {
    // Token valide présent
    const token = authService.getToken();
    if (token) {
      const decodedToken = authService.decodeToken(token);
      
      // Si les userInfo ne sont pas encore chargés, les charger
      if (!sharedService.getUserInfo()) {
        authService.loadUserInfo();
      }
      
      return true;
    }
  }

  // Gestion des tokens dans les paramètres (legacy)
  const accessToken = route.queryParams['access_token'];
  if (accessToken) {
    const currentPath = route.routeConfig?.path;
    
    if (currentPath?.startsWith('form-view')) {
      router.navigate(['/auth'], { queryParams: { accessToken, view: 'user' } });
    } else if (currentPath?.includes('dashboard') && currentPath?.includes('load-form')) {
      router.navigate(['/auth'], { queryParams: { accessToken, view: 'dashboard' } });
    } else {
      router.navigate(['/auth'], { queryParams: { accessToken } });
    }
  } else {
    // Redirection vers le login OAuth
    authService.initLoginFlow();
  }
  
  return false;
};
```

## 6. Configuration des routes

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { CallbackComponent } from './components/callback/callback.component';
import { sSOGuard } from './guards/sso.guard';

const routes: Routes = [
  { 
    path: 'callback', 
    component: CallbackComponent 
  },
  { 
    path: 'protected-route', 
    component: YourProtectedComponent,
    canActivate: [sSOGuard] 
  },
  // ... autres routes
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

## 7. Interceptor pour les appels API

```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from '../services/auth.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  constructor(private authService: AuthService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Ajouter le token aux requêtes vers Apigee
    if (req.url.includes('your-apigee-domain.com')) {
      const token = this.authService.getAccessToken();
      if (token) {
        const authReq = req.clone({
          headers: req.headers.set('Authorization', `Bearer ${token}`)
        });
        return next.handle(authReq);
      }
    }
    
    return next.handle(req);
  }
}
```

## Points importants :

1. **Discovery URL custom** : Configurez les endpoints directement dans `authConfig`
2. **Refresh automatique** : Géré par `setupAutomaticSilentRefresh()`
3. **UserInfo** : Récupéré depuis `/userinfo` et stocké dans `SharedService`
4. **Callback** : Gère la redirection après authentification
5. **Guard SSO** : Protège les routes et gère l'authentification

N'oubliez pas d'adapter les URLs et clientId selon votre configuration Apigee.





Oui, il existe aussi `loadDiscoveryDocumentAndTryLogin()` qui combine les deux opérations. Voici les différences et comment l'utiliser :

## 1. Différence entre les méthodes

```typescript
// Méthode 1: Séparée (2 étapes)
await oauthService.loadDiscoveryDocument(discoveryUrl);
await oauthService.tryLogin();

// Méthode 2: Combinée (1 étape)
await oauthService.loadDiscoveryDocumentAndTryLogin(discoveryUrl);
```

## 2. Utilisation avec URL custom

```typescript
import { Injectable } from '@angular/core';
import { OAuthService, AuthConfig } from 'angular-oauth2-oidc';

@Injectable({
  providedIn: 'root'
})
export class AuthService {

  constructor(private oauthService: OAuthService) {
    this.configureOAuth();
  }

  private authConfig: AuthConfig = {
    redirectUri: window.location.origin + '/callback',
    clientId: 'your-client-id',
    responseType: 'code',
    scope: 'openid profile email',
    showDebugInformation: true,
    strictDiscoveryDocumentValidation: false
  };

  private async configureOAuth(): Promise<void> {
    this.oauthService.configure(this.authConfig);

    // Utilisation de loadDiscoveryDocumentAndTryLogin avec URL custom
    const discoveryUrl = 'https://your-apigee-domain.com/oauth2/.well-known/openid-configuration';

    try {
      await this.oauthService.loadDiscoveryDocumentAndTryLogin(discoveryUrl);

      console.log('Discovery loaded and login attempted');

      if (this.oauthService.hasValidAccessToken()) {
        console.log('User is authenticated');
        await this.loadUserInfo();
      }

      // Configurer le refresh automatique après l'initialisation
      this.setupAutomaticTokenRefresh();

    } catch (error) {
      console.error('Error during discovery and login:', error);
    }
  }
}
```

## 3. Version complète avec gestion robuste

```typescript
import { Injectable } from '@angular/core';
import { OAuthService, AuthConfig } from 'angular-oauth2-oidc';
import { SharedService } from './shared.service';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private discoveryUrl = 'https://your-apigee-domain.com/oauth2/.well-known/openid-configuration';
  private initialized = false;

  constructor(
    private oauthService: OAuthService,
    private sharedService: SharedService
  ) {
    this.initializeAuth();
  }

  private authConfig: AuthConfig = {
    redirectUri: window.location.origin + '/callback',
    clientId: 'your-client-id',
    responseType: 'code',
    scope: 'openid profile email',
    showDebugInformation: true,
    strictDiscoveryDocumentValidation: false,
    clearHashAfterLogin: true
  };

  public async initializeAuth(): Promise<boolean> {
    if (this.initialized) {
      return true;
    }

    this.oauthService.configure(this.authConfig);

    try {
      // Étape combinée : chargement discovery + tentative login
      await this.oauthService.loadDiscoveryDocumentAndTryLogin(this.discoveryUrl);

      this.initialized = true;
      console.log('OAuth service initialized successfully');

      // Vérifier si l'utilisateur est authentifié
      if (this.oauthService.hasValidAccessToken()) {
        console.log('Valid access token found');
        await this.loadUserInfo();
        this.setupAutomaticTokenRefresh();
        return true;
      } else {
        console.log('No valid access token found');
        return false;
      }

    } catch (error) {
      console.error('Failed to initialize OAuth service:', error);
      this.initialized = false;
      return false;
    }
  }

  private setupAutomaticTokenRefresh(): void {
    this.oauthService.setupAutomaticSilentRefresh();

    this.oauthService.events.subscribe(event => {
      switch (event.type) {
        case 'token_received':
          console.log('Token received');
          this.loadUserInfo();
          break;

        case 'token_refreshed':
          console.log('Token refreshed automatically');
          break;

        case 'token_error':
          console.error('Token error:', event);
          break;
      }
    });
  }

  public async login(): Promise<void> {
    // S'assurer que l'initialisation est faite
    if (!this.initialized) {
      await this.initializeAuth();
    }

    this.oauthService.initLoginFlow();
  }

  public async loadUserInfo(): Promise<void> {
    try {
      const userInfo = await this.oauthService.loadUserProfile();

      this.sharedService.setUserInfo({
        uid: userInfo.sub,
        username: userInfo.preferred_username || userInfo.email,
        email: userInfo.email,
        avatar: userInfo.picture,
        given_name: userInfo.given_name,
        family_name: userInfo.family_name,
        name: userInfo.name
      });

    } catch (error) {
      console.error('Error loading user info:', error);
      // Fallback sur les claims du token
      const claims = this.oauthService.getIdentityClaims();
      if (claims) {
        this.sharedService.setUserInfo({
          uid: claims.sub,
          username: claims.preferred_username || claims.email,
          email: claims.email
        });
      }
    }
  }

  public getToken(): string | null {
    return this.oauthService.getAccessToken();
  }

  public hasValidToken(): boolean {
    return this.oauthService.hasValidAccessToken();
  }
}
```

## 4. Guard mis à jour pour utiliser l'initialisation

```typescript
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from '../services/auth.service';
import { SharedService } from '../services/shared.service';

export const sSOGuard: CanActivateFn = async (route, state) => {
  const authService = inject(AuthService);
  const sharedService = inject(SharedService);
  const router = inject(Router);

  // Attendre l'initialisation de l'auth
  const initialized = await authService.initializeAuth();

  if (!initialized) {
    console.error('OAuth service not initialized');
    router.navigate(['/error']);
    return false;
  }

  if (authService.hasValidToken()) {
    // Token valide présent
    const token = authService.getToken();
    if (token) {
      // Si les userInfo ne sont pas encore chargés, les charger
      if (!sharedService.getUserInfo()) {
        await authService.loadUserInfo();
      }
      return true;
    }
  }

  // Gestion des tokens legacy dans les paramètres
  const accessToken = route.queryParams['access_token'];
  if (accessToken) {
    const currentPath = route.routeConfig?.path;

    if (currentPath?.startsWith('form-view')) {
      router.navigate(['/auth'], { queryParams: { accessToken, view: 'user' } });
    } else if (currentPath?.includes('dashboard') && currentPath?.includes('load-form')) {
      router.navigate(['/auth'], { queryParams: { accessToken, view: 'dashboard' } });
    } else {
      router.navigate(['/auth'], { queryParams: { accessToken } });
    }
  } else {
    // Redirection vers le login OAuth
    authService.login();
  }

  return false;
};
```

## 5. Callback Component simplifié

```typescript
import { Component, OnInit } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';
import { AuthService } from '../services/auth.service';

@Component({
  selector: 'app-callback',
  template: `
    <div class="callback-container">
      <div class="spinner"></div>
      <p>Traitement de la connexion...</p>
    </div>
  `,
  styles: [`
    .callback-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 2s linear infinite;
      margin-bottom: 16px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `]
})
export class CallbackComponent implements OnInit {

  constructor(
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  async ngOnInit(): Promise<void> {
    // La méthode loadDiscoveryDocumentAndTryLogin est déjà appelée dans l'initialization
    // Ici on vérifie juste le statut de l'authentification

    if (this.authService.hasValidToken()) {
      // Connexion réussie
      const returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';
      this.router.navigate([returnUrl]);
    } else {
      // Échec de la connexion
      console.error('Authentication failed in callback');
      this.router.navigate(['/auth'], {
        queryParams: { error: 'authentication_failed' }
      });
    }
  }
}
```

## 6. AppComponent avec initialisation

```typescript
import { Component, OnInit } from '@angular/core';
import { AuthService } from './services/auth.service';

@Component({
  selector: 'app-root',
  template: `
    <div *ngIf="!initialized" class="app-loading">
      <p>Initialisation de l'application...</p>
    </div>

    <div *ngIf="initialized">
      <router-outlet></router-outlet>
    </div>
  `
})
export class AppComponent implements OnInit {
  initialized = false;

  constructor(private authService: AuthService) {}

  async ngOnInit(): Promise<void> {
    // Initialiser l'authentification au démarrage de l'app
    this.initialized = await this.authService.initializeAuth();

    if (!this.initialized) {
      console.error('Application failed to initialize');
    }
  }
}
```

## Avantages de `loadDiscoveryDocumentAndTryLogin` :

1. **Plus simple** : Une seule méthode à appeler
2. **Plus robuste** : Gère la séquence correctement
3. **Moins de code** : Réduction du code boilerplate
4. **Meilleure gestion d'erreur** : Une seule promesse à catcher

C'est la méthode recommandée pour la plupart des cas d'utilisation, surtout avec des URLs de discovery custom comme avec Apigee.
Je vois plusieurs probl√®mes dans votre code SSE (Server-Sent Events) actuel. Voici une version corrig√©e et optimis√©e :

## üîß **1. Service Angular corrig√©**

```typescript
// application-monitor.service.ts
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { environment } from '../../../environments/environment';

@Injectable({ providedIn: 'root' })
export class ApplicationMonitorService {
  private apiUrl = `${environment.apiUrl}/notifications/app`;

  listenForAppChange(appId: string): Observable<boolean> {
    return new Observable<boolean>(observer => {
      const eventSource = new EventSource(`${this.apiUrl}/${appId}`);

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.changed) {
            observer.next(true);
          }
        } catch (error) {
          console.error('Error parsing SSE message:', error);
        }
      };

      eventSource.onerror = (error) => {
        console.error('App change SSE error:', error);
        // Ne pas fermer automatiquement, la reconnexion est g√©r√©e automatiquement
      };

      // Nettoyage √† la d√©sinscription
      return () => {
        eventSource.close();
      };
    });
  }
}
```

```typescript
// presence.service.ts
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { environment } from '../../environments/environment';
import { SharedService } from './shared.service';
import { HttpClient, HttpHeaders } from '@angular/common/http';

@Injectable({ providedIn: 'root' })
export class PresenceService {
  private apiUrl = `${environment.apiUrl}/presence`;
  private readonly HEARTBEAT_INTERVAL = 15000; // 15 secondes
  private heartbeatInterval: any;

  constructor(private http: HttpClient, private sharedService: SharedService) {}

  private getHeaders(): HttpHeaders {
    const token = localStorage.getItem('sso_token') || '';
    return new HttpHeaders({
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  // üî• Version unique et simplifi√©e
  startPresenceTracking(accessToken: string): void {
    this.updatePresence(accessToken); // Premier appel imm√©diat

    // Heartbeat p√©riodique
    this.heartbeatInterval = setInterval(() => {
      this.updatePresence(accessToken);
    }, this.HEARTBEAT_INTERVAL);
  }

  stopPresenceTracking(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  updatePresence(accessToken: string): Observable<any> {
    const user = this.sharedService.getUserInfo();
    if (!user?.uid || !user?.username) {
      console.warn('User info missing for presence update');
      return new Observable();
    }

    const payload = {
      viewer_id: user.uid,
      username: user.username
    };

    return this.http.post(
      `${this.apiUrl}/${accessToken}`,
      payload,
      { headers: this.getHeaders() }
    );
  }

  streamPresence(accessToken: string): Observable<string[]> {
    return new Observable<string[]>(observer => {
      const eventSource = new EventSource(`${this.apiUrl}/${accessToken}/stream`);

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          observer.next(data);
        } catch (error) {
          console.error('Error parsing presence data:', error);
        }
      };

      eventSource.onerror = (error) => {
        console.error('Presence SSE error:', error);
        observer.error(error);
      };

      // Nettoyage
      return () => {
        eventSource.close();
      };
    });
  }
}
```

## üöÄ **2. Blueprints Flask optimis√©s**

```python
# notification_bp.py
from flask import Blueprint, Response, request
import time
import json
import logging
from api.extensions import redis_client
from api.routes.auth_decorators import require_user_token, require_api_token

logger = logging.getLogger(__name__)
notification_bp = Blueprint("notification_bp", __name__)

@notification_bp.route("/notifications/app/<string:app_id>")
@require_api_token  # Ou require_user_token selon vos besoins
def stream_app_updates(app_id):
    """
    SSE pour les notifications de changement d'application
    Utilise Redis Pub/Sub pour une meilleure performance
    """
    def event_stream():
        try:
            # V√©rifier initiale
            last_data = redis_client.get(f"app:changed:{app_id}")

            while True:
                # V√©rifier si le client est toujours connect√©
                if request.environ.get('werkzeug.server.shutdown'):
                    break

                current_data = redis_client.get(f"app:changed:{app_id}")

                # üî• Optimisation: ne envoyer que si changement d√©tect√©
                if current_data and current_data != last_data:
                    yield f"data: {json.dumps({'changed': True, 'timestamp': time.time()})}\n\n"
                    last_data = current_data
                    # Flusher imm√©diatement
                    yield ''

                time.sleep(2)  # Intervalle r√©duit pour meilleure r√©activit√©

        except GeneratorExit:
            logger.info(f"Client disconnected from app notifications for {app_id}")
        except Exception as e:
            logger.error(f"Error in app notification stream for {app_id}: {e}")

    return Response(
        event_stream(),
        mimetype="text/event-stream",
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'X-Accel-Buffering': 'no'  # Important pour Nginx
        }
    )

# Endpoint pour d√©clencher les notifications
@notification_bp.route("/notifications/app/<string:app_id>/notify", methods=["POST"])
@require_api_token
def notify_app_change(app_id):
    """D√©clenche une notification de changement pour une application"""
    try:
        import time
        timestamp = str(time.time())
        redis_client.setex(f"app:changed:{app_id}", 300, timestamp)  # Expire apr√®s 5min
        logger.info(f"App change notified for {app_id}")
        return {"status": "success", "app_id": app_id}
    except Exception as e:
        logger.error(f"Error notifying app change for {app_id}: {e}")
        return {"error": str(e)}, 500
```

```python
# presence_bp.py
from flask import Blueprint, request, jsonify, Response
from api.extensions import redis_client
from api.helpers.tools import error_response
from api.routes.auth_decorators import require_user_token
import time
import json
import logging

logger = logging.getLogger(__name__)
presence_bp = Blueprint("presence_bp", __name__)

# üî• Configuration optimis√©e
PRESENCE_TTL = 25  # 25 secondes (sup√©rieur √† l'intervalle client)
CLEANUP_INTERVAL = 30  # Nettoyage toutes les 30 secondes
last_cleanup = time.time()

@presence_bp.route("/presence/<string:access_token>", methods=["POST"])
@require_user_token
def register_presence(access_token):
    """Enregistre/met √† jour la pr√©sence d'un utilisateur"""
    try:
        data = request.get_json()
        if not data:
            return error_response("JSON body required", 400)

        uid = getattr(request, 'user_id', None)
        username = data.get("username")

        if not uid or not username:
            return error_response("User info missing", 400)

        # üî• Structure de donn√©es optimis√©e
        user_key = f"presence:{access_token}:{uid}"
        user_data = {
            "username": username,
            "user_id": uid,
            "last_seen": time.time(),
            "access_token": access_token
        }

        # Stockage avec TTL
        redis_client.setex(
            user_key,
            PRESENCE_TTL,
            json.dumps(user_data)
        )

        # Mettre √† jour la liste des tokens actifs
        tokens_key = f"presence:tokens"
        redis_client.sadd(tokens_key, access_token)
        redis_client.expire(tokens_key, 3600)  # Expire apr√®s 1h

        logger.debug(f"Presence updated for user {username} on token {access_token}")
        return jsonify({"message": "Presence updated", "ttl": PRESENCE_TTL}), 200

    except Exception as e:
        logger.error(f"Error updating presence: {e}")
        return error_response("Internal server error", 500)

@presence_bp.route("/presence/<string:access_token>/stream", methods=["GET"])
@require_user_token
def stream_presence(access_token):
    """Stream SSE pour les mises √† jour de pr√©sence"""

    def event_stream():
        global last_cleanup
        last_viewers = set()

        try:
            while True:
                # V√©rifier si le client est toujours connect√©
                if request.environ.get('werkzeug.server.shutdown'):
                    break

                # üî• Nettoyage p√©riodique des donn√©es expir√©es
                current_time = time.time()
                if current_time - last_cleanup > CLEANUP_INTERVAL:
                    cleanup_expired_presence(access_token)
                    last_cleanup = current_time

                # R√©cup√©ration des viewers actuels
                current_viewers = get_current_viewers(access_token)

                # üî• Envoyer seulement si changement d√©tect√©
                if current_viewers != last_viewers:
                    viewers_list = list(current_viewers)
                    yield f"data: {json.dumps(viewers_list)}\n\n"
                    yield ''  # Flusher
                    last_viewers = current_viewers

                time.sleep(3)  # Intervalle r√©duit

        except GeneratorExit:
            logger.info(f"Client disconnected from presence stream for token {access_token}")
        except Exception as e:
            logger.error(f"Error in presence stream for token {access_token}: {e}")

    return Response(
        event_stream(),
        mimetype="text/event-stream",
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'X-Accel-Buffering': 'no'
        }
    )

def get_current_viewers(access_token):
    """R√©cup√®re la liste actuelle des viewers pour un token"""
    try:
        # üî• Utilisation de SCAN pour √©viter de bloquer Redis
        pattern = f"presence:{access_token}:*"
        viewers = set()
        cursor = 0

        while True:
            cursor, keys = redis_client.scan(cursor=cursor, match=pattern, count=100)

            for key in keys:
                try:
                    user_data_json = redis_client.get(key)
                    if user_data_json:
                        user_data = json.loads(user_data_json)
                        viewers.add(user_data["username"])
                except (json.JSONDecodeError, KeyError) as e:
                    logger.warning(f"Invalid user data in key {key}: {e}")
                    continue

            if cursor == 0:
                break

        return viewers
    except Exception as e:
        logger.error(f"Error getting current viewers: {e}")
        return set()

def cleanup_expired_presence(access_token=None):
    """Nettoie les entr√©es de pr√©sence expir√©es"""
    try:
        if access_token:
            # Nettoyage pour un token sp√©cifique
            pattern = f"presence:{access_token}:*"
        else:
            # Nettoyage global
            pattern = "presence:*:*"

        cursor = 0
        deleted_count = 0

        while True:
            cursor, keys = redis_client.scan(cursor=cursor, match=pattern, count=100)

            if not keys:
                break

            # Les cl√©s expir√©es sont automatiquement supprim√©es par Redis gr√¢ce au TTL
            # On pourrait ajouter une v√©rification manuelle si n√©cessaire
            deleted_count += len(keys)

            if cursor == 0:
                break

        if deleted_count > 0:
            logger.debug(f"Cleaned up {deleted_count} presence entries")

    except Exception as e:
        logger.error(f"Error during presence cleanup: {e}")

# Endpoint pour r√©cup√©rer l'√©tat actuel
@presence_bp.route("/presence/<string:access_token>/viewers", methods=["GET"])
@require_user_token
def get_current_viewers_endpoint(access_token):
    """Retourne la liste actuelle des viewers"""
    try:
        viewers = list(get_current_viewers(access_token))
        return jsonify({
            "viewers": viewers,
            "count": len(viewers),
            "access_token": access_token
        })
    except Exception as e:
        logger.error(f"Error getting viewers for {access_token}: {e}")
        return error_response("Internal server error", 500)
```

## üîß **3. Composant Angular d'exemple**

```typescript
// app-presence.component.ts
import { Component, OnInit, OnDestroy } from '@angular/core';
import { PresenceService } from '../services/presence.service';
import { ApplicationMonitorService } from '../services/application-monitor.service';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-presence',
  template: `
    <div class="presence-container">
      <h3>Viewers en ligne: {{ viewers.length }}</h3>
      <ul>
        <li *ngFor="let viewer of viewers">{{ viewer }}</li>
      </ul>

      <div *ngIf="appChanged" class="app-change-alert">
        üîÑ L'application a √©t√© modifi√©e
      </div>
    </div>
  `
})
export class PresenceComponent implements OnInit, OnDestroy {
  viewers: string[] = [];
  appChanged = false;
  private subscriptions = new Subscription();
  private accessToken = 'your-access-token'; // √Ä remplacer

  constructor(
    private presenceService: PresenceService,
    private appMonitor: ApplicationMonitorService
  ) {}

  ngOnInit() {
    this.startPresenceTracking();
    this.startAppMonitoring();
  }

  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.presenceService.stopPresenceTracking();
  }

  private startPresenceTracking() {
    // D√©marrer le heartbeat
    this.presenceService.startPresenceTracking(this.accessToken);

    // S'abonner aux mises √† jour de pr√©sence
    this.subscriptions.add(
      this.presenceService.streamPresence(this.accessToken).subscribe({
        next: (viewers) => {
          this.viewers = viewers;
        },
        error: (error) => {
          console.error('Presence stream error:', error);
          // Reconnexion automatique apr√®s d√©lai
          setTimeout(() => this.startPresenceTracking(), 5000);
        }
      })
    );
  }

  private startAppMonitoring() {
    this.subscriptions.add(
      this.appMonitor.listenForAppChange('your-app-id').subscribe({
        next: (changed) => {
          this.appChanged = true;
          // Reset apr√®s 5 secondes
          setTimeout(() => this.appChanged = false, 5000);
        },
        error: (error) => {
          console.error('App monitoring error:', error);
        }
      })
    );
  }
}
```

## ‚öôÔ∏è **4. Configuration Nginx recommand√©e**

```nginx
# Configuration pour SSE
server {
    listen 80;
    server_name your-domain.com;

    location /api/ {
        proxy_pass http://your-flask-app:5000;

        # Configuration SSE
        proxy_set_header Connection '';
        proxy_http_version 1.1;
        chunked_transfer_encoding off;
        proxy_buffering off;
        proxy_cache off;

        # Timeouts longs pour SSE
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }
}
```

## üöÄ **5. Script de test**

```python
# test_sse.py
import requests
import json
import time

def test_presence():
    """Test le syst√®me de pr√©sence"""
    base_url = "http://localhost:5000"
    token = "your-test-token"

    # Mettre √† jour la pr√©sence
    response = requests.post(
        f"{base_url}/presence/{token}",
        json={"username": "test-user", "viewer_id": "123"},
        headers={"Authorization": "Bearer your-jwt-token"}
    )
    print("Presence update:", response.status_code)

    # R√©cup√©rer les viewers actuels
    response = requests.get(
        f"{base_url}/presence/{token}/viewers",
        headers={"Authorization": "Bearer your-jwt-token"}
    )
    print("Current viewers:", response.json())

if __name__ == "__main__":
    test_presence()
```

## ‚úÖ **Am√©liorations apport√©es** :

1. **üéØ Performance** : Utilisation de SCAN au lieu de KEYS pour √©viter de bloquer Redis
2. **üöÄ R√©activit√©** : Intervalles r√©duits (2-3s au lieu de 5s)
3. **üîí Robustesse** : Gestion compl√®te des erreurs et reconnexions
4. **üßπ Nettoyage** : Gestion automatique des donn√©es expir√©es
5. **üì± Client Angular** : Code simplifi√© et meilleure gestion des subscriptions
6. **üîß Configuration** : Headers SSE optimis√©s pour Nginx
7. **üìä Monitoring** : Logging complet pour le d√©bogage

Cette version est **production-ready** et bien plus performante que l'originale ! üéâ



































Voici la configuration optimis√©e pour **Apache HTTPD** avec les directives sp√©cifiques pour SSE :

## üîß **1. Configuration Apache HTTPD pour SSE**

```apache
# httpd-vhosts.conf ou dans votre VirtualHost
<VirtualHost *:80>
    ServerName your-domain.com
    DocumentRoot "/path/to/your/app"

    # Configuration g√©n√©rale pour l'API
    ProxyPreserveHost On
    ProxyRequests Off

    # Proxy vers l'application Flask
    ProxyPass /api/ http://localhost:5000/api/
    ProxyPassReverse /api/ http://localhost:5000/api/

    # üî• Configuration sp√©cifique pour les SSE (Server-Sent Events)
    <Location /api/notifications/>
        # D√©sactiver la mise en cache et le buffering pour SSE
        ProxyPass http://localhost:5000/api/notifications/
        ProxyPassReverse http://localhost:5000/api/notifications/

        # Headers importants pour SSE
        Header always set Cache-Control "no-cache"
        Header always set Connection "keep-alive"
        Header always set X-Accel-Buffering "no"

        # Timeouts longs pour les connexions persistantes
        ProxyTimeout 3600
        Timeout 3600
        ProxySet flushpackets=on
        ProxySet disablereuse=off
    </Location>

    <Location /api/presence/>
        # M√™me configuration pour les streams de pr√©sence
        ProxyPass http://localhost:5000/api/presence/
        ProxyPassReverse http://localhost:5000/api/presence/

        Header always set Cache-Control "no-cache"
        Header always set Connection "keep-alive"
        Header always set X-Accel-Buffering "no"

        ProxyTimeout 3600
        Timeout 3600
        ProxySet flushpackets=on
        ProxySet disablereuse=off
    </Location>

    # Compression pour les autres endpoints (optionnel)
    <Location /api/>
        SetOutputFilter DEFLATE
        Header always set Cache-Control "no-cache"
    </Location>

</VirtualHost>
```

## üöÄ **2. Version avanc√©e avec mod_proxy_wstunnel** (si disponible)

```apache
# Si vous avez mod_proxy_wstunnel pour WebSocket/SSE
LoadModule proxy_wstunnel_module modules/mod_proxy_wstunnel.so

<VirtualHost *:80>
    ServerName your-domain.com

    # Configuration standard
    ProxyPreserveHost On
    ProxyRequests Off

    # Routes SSE sp√©cifiques
    ProxyPass /api/notifications/ http://localhost:5000/api/notifications/
    ProxyPassReverse /api/notifications/ http://localhost:5000/api/notifications/

    ProxyPass /api/presence/ http://localhost:5000/api/presence/
    ProxyPassReverse /api/presence/ http://localhost:5000/api/presence/

    # Configuration pour les streams (SSE)
    <LocationMatch "/api/(notifications|presence)/.*/stream">
        ProxyPass http://localhost:5000/api/$1/
        ProxyPassReverse http://localhost:5000/api/$1/

        # Configuration critique pour SSE
        ProxySet flushpackets=on
        ProxySet disablereuse=on

        # Headers
        Header always set Cache-Control "no-cache, no-store, must-revalidate"
        Header always set Pragma "no-cache"
        Header always set Expires "0"
        Header always set Connection "keep-alive"
        Header always set X-Accel-Buffering "no"

        # Timeouts
        ProxyTimeout 3600
        Timeout 3600
    </LocationMatch>

</VirtualHost>
```

## üîß **3. Fichier .htaccess alternative** (si vous n'avez pas acc√®s √† la config Apache)

```apache
# .htaccess √† la racine de votre application
RewriteEngine On

# D√©sactiver la compression pour les streams SSE (peut interf√©rer)
<IfModule mod_deflate.c>
    SetEnvIfNoCase Request_URI "/api/(notifications|presence)/" no-gzip=1
</IfModule>

# Headers pour les endpoints SSE
<LocationMatch "/api/(notifications|presence)/">
    Header always set Cache-Control "no-cache"
    Header always set Connection "keep-alive"
    Header always set X-Accel-Buffering "no"
</LocationMatch>

# Proxy vers Flask (si n√©cessaire)
RewriteCond %{REQUEST_URI} ^/api/
RewriteRule ^api/(.*)$ http://localhost:5000/api/$1 [P,L]
```

## üêõ **4. Code Flask adapt√© pour Apache**

```python
# notification_bp.py - Version adapt√©e pour Apache
from flask import Blueprint, Response, request, jsonify
import time
import json
import logging
from api.extensions import redis_client
from api.routes.auth_decorators import require_user_token, require_api_token

logger = logging.getLogger(__name__)
notification_bp = Blueprint("notification_bp", __name__)

@notification_bp.route("/notifications/app/<string:app_id>")
@require_api_token
def stream_app_updates(app_id):
    """
    SSE optimis√© pour Apache HTTPD
    """
    def event_stream():
        try:
            # Envoyer un commentaire initial pour √©tablir la connexion
            yield ": SSE Connection Established\n\n"

            last_data = None
            consecutive_errors = 0
            max_errors = 5

            while True:
                try:
                    # V√©rifier p√©riodiquement si le client est parti
                    if hasattr(request, 'environ') and request.environ.get('wsgi.input').closed:
                        logger.info(f"Client disconnected for app {app_id}")
                        break

                    current_data = redis_client.get(f"app:changed:{app_id}")

                    if current_data and current_data != last_data:
                        event_data = json.dumps({
                            'changed': True,
                            'timestamp': time.time(),
                            'app_id': app_id
                        })
                        yield f"data: {event_data}\n\n"
                        # üî• IMPORTANT: Flusher avec une ligne vide
                        yield ''
                        last_data = current_data
                        consecutive_errors = 0  # Reset error count on success

                    time.sleep(2)

                except Exception as e:
                    consecutive_errors += 1
                    logger.warning(f"Error in SSE loop for {app_id} (attempt {consecutive_errors}): {e}")

                    if consecutive_errors >= max_errors:
                        logger.error(f"Too many errors for {app_id}, stopping stream")
                        break

                    time.sleep(1)  # Attendre avant de r√©essayer

        except GeneratorExit:
            logger.info(f"SSE generator closed for app {app_id}")
        except Exception as e:
            logger.error(f"Unexpected error in SSE for {app_id}: {e}")

    # üî• Headers critiques pour Apache
    headers = {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no',  # D√©sactive la mise en buffer
        'Access-Control-Allow-Origin': '*',  # Si CORS est n√©cessaire
    }

    return Response(event_stream(), headers=headers)
```

```python
# presence_bp.py - Version adapt√©e pour Apache
from flask import Blueprint, request, jsonify, Response
from api.extensions import redis_client
from api.helpers.tools import error_response
from api.routes.auth_decorators import require_user_token
import time
import json
import logging

logger = logging.getLogger(__name__)
presence_bp = Blueprint("presence_bp", __name__)

PRESENCE_TTL = 25
CLEANUP_INTERVAL = 30
last_cleanup = time.time()

@presence_bp.route("/presence/<string:access_token>/stream")
@require_user_token
def stream_presence(access_token):
    """Stream SSE de pr√©sence optimis√© pour Apache"""

    def event_stream():
        global last_cleanup
        last_viewers = set()

        try:
            # Commentaire initial
            yield ": Presence SSE Connection Established\n\n"

            while True:
                try:
                    # V√©rification de connexion client
                    if hasattr(request, 'environ') and request.environ.get('wsgi.input').closed:
                        break

                    # Nettoyage p√©riodique
                    current_time = time.time()
                    if current_time - last_cleanup > CLEANUP_INTERVAL:
                        cleanup_expired_presence(access_token)
                        last_cleanup = current_time

                    # R√©cup√©ration viewers
                    current_viewers = get_current_viewers(access_token)

                    # Envoi seulement si changement
                    if current_viewers != last_viewers:
                        event_data = json.dumps(list(current_viewers))
                        yield f"data: {event_data}\n\n"
                        yield ''  # Flusher
                        last_viewers = current_viewers

                    time.sleep(3)

                except Exception as e:
                    logger.warning(f"Error in presence stream loop: {e}")
                    time.sleep(1)  # Pause avant retry

        except GeneratorExit:
            logger.info(f"Presence stream closed for token {access_token}")
        except Exception as e:
            logger.error(f"Unexpected error in presence stream: {e}")

    headers = {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no',
        'Access-Control-Allow-Origin': '*',
    }

    return Response(event_stream(), headers=headers)

# Les autres fonctions (get_current_viewers, cleanup_expired_presence) restent identiques
def get_current_viewers(access_token):
    """R√©cup√®re la liste actuelle des viewers"""
    try:
        pattern = f"presence:{access_token}:*"
        viewers = set()
        cursor = 0

        while True:
            cursor, keys = redis_client.scan(cursor=cursor, match=pattern, count=100)

            for key in keys:
                try:
                    user_data_json = redis_client.get(key)
                    if user_data_json:
                        user_data = json.loads(user_data_json)
                        viewers.add(user_data["username"])
                except (json.JSONDecodeError, KeyError) as e:
                    logger.warning(f"Invalid user data in key {key}: {e}")
                    continue

            if cursor == 0:
                break

        return viewers
    except Exception as e:
        logger.error(f"Error getting current viewers: {e}")
        return set()

def cleanup_expired_presence(access_token=None):
    """Nettoie les entr√©es de pr√©sence expir√©es"""
    try:
        if access_token:
            pattern = f"presence:{access_token}:*"
        else:
            pattern = "presence:*:*"

        cursor = 0
        deleted_count = 0

        while True:
            cursor, keys = redis_client.scan(cursor=cursor, match=pattern, count=100)

            if not keys:
                break

            deleted_count += len(keys)

            if cursor == 0:
                break

        if deleted_count > 0:
            logger.debug(f"Cleaned up {deleted_count} presence entries")

    except Exception as e:
        logger.error(f"Error during presence cleanup: {e}")
```

## üîç **5. Script de test Apache**

```python
# test_apache_sse.py
import requests
import time
import threading

def test_sse_connection():
    """Test de connexion SSE avec gestion des timeouts Apache"""
    base_url = "http://your-domain.com/api"
    token = "test-token-123"

    def read_sse_stream():
        try:
            response = requests.get(
                f"{base_url}/presence/{token}/stream",
                headers={"Authorization": "Bearer your-jwt-token"},
                stream=True,
                timeout=35  # Timeout l√©g√®rement sup√©rieur √† Apache
            )

            print(f"Status Code: {response.status_code}")
            print(f"Headers: {response.headers}")

            for line in response.iter_lines(decode_unicode=True):
                if line:
                    print(f"Received: {line}")

        except requests.exceptions.Timeout:
            print("SSE connection timeout (Apache config working)")
        except Exception as e:
            print(f"SSE error: {e}")

    # Lancer dans un thread pour pouvoir l'interrompre
    thread = threading.Thread(target=read_sse_stream)
    thread.start()

    # Attendre un peu puis interrompre
    time.sleep(10)
    print("Test completed")

if __name__ == "__main__":
    test_sse_connection()
```

## üõ†Ô∏è **6. Commandes de diagnostic Apache**

```bash
# V√©rifier les modules Apache charg√©s
httpd -M | grep proxy

# Red√©marrer Apache apr√®s configuration
sudo systemctl restart httpd

# V√©rifier les erreurs
sudo tail -f /var/log/httpd/error_log

# V√©rifier les logs d'acc√®s SSE
sudo tail -f /var/log/httpd/access_log | grep -E "(notifications|presence)"

# Test de connexion curl
curl -N -H "Authorization: Bearer YOUR_TOKEN" \
     -H "Cache-Control: no-cache" \
     http://localhost/api/notifications/app/test-app
```

## ‚ö° **7. Optimisations suppl√©mentaires pour Apache**

```apache
# Dans httpd.conf pour optimiser les performances SSE
# Timeouts globaux
Timeout 3600

# KeepAlive settings (peut aider avec les connexions persistantes)
KeepAlive On
KeepAliveTimeout 5
MaxKeepAliveRequests 100

# Buffer sizes (peut am√©liorer les performances)
ProxyIOBufferSize 8192

# Limiter la taille des buffers pour les streams
ProxyReceiveBufferSize 0

# D√©sactiver la mise en cache pour les routes API
<Location "/api/">
    FileETag None
    Header unset ETag
    Header always set Cache-Control "no-cache, no-store, must-revalidate"
    Header always set Pragma "no-cache"
    Header always set Expires "0"
</Location>
```

## ‚úÖ **Points cl√©s pour Apache :**

1. **`ProxySet flushpackets=on`** - Force l'envoi imm√©diat des donn√©es
2. **`ProxyTimeout 3600`** - Timeout long pour les connexions persistantes
3. **`Header always set X-Accel-Buffering "no"`** - D√©sactive le buffering
4. **`yield ''`** dans Flask - Force le flush des donn√©es
5. **Content-Type: text/event-stream** - Essentiel pour SSE

Cette configuration devrait r√©soudre les probl√®mes de buffering et de timeouts avec Apache HTTPD ! üöÄ
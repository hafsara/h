Tr√®s bonne question üí™ ‚Äî tu veux donc **remplacer proprement la cl√© √©trang√®re `app_token` par `app_id`** dans PostgreSQL, **sans perdre les donn√©es existantes**.
Voici la **proc√©dure compl√®te, claire et s√©curis√©e** üëá

---

## ‚öôÔ∏è 1Ô∏è‚É£ V√©rifier la colonne actuelle

Ouvre `psql` ou ton outil (pgAdmin, DBeaver...) et ex√©cute :

```sql
\d email_templates;
```

Tu devrais voir quelque chose comme :

```
app_token character varying(36)
```

---

## üß© 2Ô∏è‚É£ Ajouter la nouvelle colonne `app_id`

On ajoute d‚Äôabord la nouvelle colonne, en la remplissant avec les m√™mes valeurs que l‚Äôancienne :

```sql
ALTER TABLE email_templates
ADD COLUMN app_id VARCHAR(36);
```

Puis on copie les valeurs existantes :

```sql
UPDATE email_templates
SET app_id = app_token;
```

---

## üîó 3Ô∏è‚É£ Cr√©er la nouvelle contrainte de cl√© √©trang√®re

Ajoute la contrainte FK vers la table `application` :

```sql
ALTER TABLE email_templates
ADD CONSTRAINT fk_email_templates_app
FOREIGN KEY (app_id)
REFERENCES application(id)
ON DELETE SET NULL
ON UPDATE CASCADE;
```

‚úÖ Ici, `ON UPDATE CASCADE` permet √† PostgreSQL de **propager automatiquement** les changements d‚Äô`application.id` vers `email_templates.app_id` ‚Äî
donc **plus d‚ÄôIntegrityError** si tu fais une rotation de token.

---

## üßπ 4Ô∏è‚É£ Supprimer l‚Äôancienne colonne

Une fois que tout est bon :

```sql
ALTER TABLE email_templates
DROP COLUMN app_token;
```

---

## üìú 5Ô∏è‚É£ V√©rifier

Tu peux v√©rifier avec :

```sql
\d email_templates;
```

Tu devrais maintenant voir :

```
app_id character varying(36)
   References: application(id)
   On update: CASCADE
   On delete: SET NULL
```

---

## üöÄ 6Ô∏è‚É£ (Optionnel) ‚Äî Si tu veux faire √ßa avec Alembic

Si ton projet Flask utilise Alembic (souvent le cas), fais plut√¥t :

```bash
alembic revision -m "replace app_token with app_id in EmailTemplate"
```

Puis √©dite le fichier g√©n√©r√© dans `migrations/versions/` et mets :

```python
def upgrade():
    op.add_column('email_templates', sa.Column('app_id', sa.String(length=36), nullable=True))
    op.execute('UPDATE email_templates SET app_id = app_token')
    op.create_foreign_key(
        'fk_email_templates_app',
        'email_templates', 'application',
        ['app_id'], ['id'],
        onupdate='CASCADE',
        ondelete='SET NULL'
    )
    op.drop_column('email_templates', 'app_token')

def downgrade():
    op.add_column('email_templates', sa.Column('app_token', sa.String(length=36), nullable=True))
    op.execute('UPDATE email_templates SET app_token = app_id')
    op.drop_constraint('fk_email_templates_app', 'email_templates', type_='foreignkey')
    op.drop_column('email_templates', 'app_id')
```

Puis applique :

```bash
alembic upgrade head
```

---

## ‚úÖ R√©sultat attendu

Une fois la migration faite, tu pourras :

* modifier `application.id` sans `IntegrityError` (merci √† `ON UPDATE CASCADE`);
* garder toutes les r√©f√©rences coh√©rentes dans `email_templates`.

---

Souhaites-tu que je te montre **la m√™me migration** mais **pour toutes les tables li√©es √† `application.id` (FormContainer, Campaign, etc.)**, avec les bonnes contraintes `ON UPDATE CASCADE` ?
√áa te permettrait de rendre la rotation du token 100 % fiable sur toute la base.

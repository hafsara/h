Pour g√©rer l'authentification server-to-server via Apigee avec des tokens JWT, voici une solution compl√®te qui s'int√®gre avec votre syst√®me existant :

## üîß **1. Am√©lioration du syst√®me d'authentification**

```python
# api/auth/middleware.py
import jwt
from flask import request, jsonify, abort, current_app
from functools import wraps
from api.models import Application, APIToken
from config import Config
import logging

logger = logging.getLogger(__name__)

class AuthManager:
    """Gestionnaire centralis√© d'authentification pour tous les types de tokens"""

    def __init__(self):
        self.token_types = {
            'user': self._validate_user_token,
            'api': self._validate_api_token,
            'server': self._validate_server_token
        }

    def authenticate_request(self):
        """
        Middleware principal qui g√®re tous les types de tokens
        """
        if request.method == 'OPTIONS':
            return

        try:
            auth_header = request.headers.get('Authorization')
            if not auth_header:
                return jsonify({"error": "Authorization header required"}), 401

            token = self._extract_token(auth_header)
            if not token:
                return jsonify({"error": "Invalid authorization format"}), 401

            # D√©codage du token pour identifier le type
            decoded_token = self._decode_token(token)
            if not decoded_token:
                return jsonify({"error": "Invalid token"}), 401

            # Identification du type de token et validation
            token_type = self._identify_token_type(decoded_token)
            validation_method = self.token_types.get(token_type)

            if not validation_method:
                return jsonify({"error": "Unsupported token type"}), 401

            return validation_method(token, decoded_token)

        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return jsonify({"error": "Authentication failed", "details": str(e)}), 401

    def _extract_token(self, auth_header):
        """Extrait le token de l'en-t√™te Authorization"""
        parts = auth_header.split()
        if len(parts) == 2 and parts[0].lower() == 'bearer':
            return parts[1]
        elif len(parts) == 1:
            return parts[0]  # Format personnalis√© sans 'Bearer'
        return None

    def _decode_token(self, token):
        """D√©codage basique du token JWT"""
        try:
            return jwt.decode(token, Config.SECRET_KEY, algorithms=['HS256'], options={"verify_exp": True})
        except jwt.ExpiredSignatureError:
            raise Exception("Token expired")
        except jwt.InvalidTokenError as e:
            raise Exception(f"Invalid token: {e}")

    def _identify_token_type(self, decoded_token):
        """Identifie le type de token bas√© sur son contenu"""
        if "app_names" in decoded_token and "token_type" in decoded_token:
            return decoded_token.get("token_type")  # 'api' ou 'server'
        elif "sub" in decoded_token:
            return "user"
        else:
            raise Exception("Unknown token type")

    def _validate_user_token(self, token, decoded_token):
        """Validation des tokens utilisateur standards"""
        request.user_id = decoded_token["sub"]
        request.app_names = None
        request.token_type = "user"
        request.token_permissions = {"read": True, "write": True}  # Par d√©faut pour les users

    def _validate_api_token(self, token, decoded_token):
        """Validation des tokens API existants"""
        token_entry = APIToken.query.filter_by(token=token).first()
        if not token_entry or not token_entry.is_active:
            raise Exception("API token revoked or invalid")

        request.app_names = decoded_token["app_names"]
        request.user_id = decoded_token.get("token_name")
        request.token_type = "api"
        request.token_permissions = getattr(token_entry, 'permissions', {"read": True, "write": False})

    def _validate_server_token(self, token, decoded_token):
        """
        Validation des tokens server-to-server pour Apigee
        Structure attendue:
        {
            "token_type": "server",
            "client_id": "apigee-client-1",
            "app_names": ["app1", "app2"],
            "permissions": ["read", "write"],
            "scope": "api:read api:write",
            "exp": 1234567890
        }
        """
        # V√©rification des champs obligatoires
        required_fields = ["client_id", "app_names", "permissions"]
        for field in required_fields:
            if field not in decoded_token:
                raise Exception(f"Missing required field: {field}")

        # V√©rification que le client est autoris√©
        client_id = decoded_token["client_id"]
        if not self._is_authorized_client(client_id):
            raise Exception(f"Unauthorized client: {client_id}")

        # V√©rification que les applications existent
        app_names = decoded_token["app_names"]
        valid_apps = Application.query.filter(Application.name.in_(app_names)).all()
        if len(valid_apps) != len(app_names):
            invalid_apps = set(app_names) - {app.name for app in valid_apps}
            raise Exception(f"Invalid applications: {', '.join(invalid_apps)}")

        # Stockage dans le contexte de la requ√™te
        request.app_names = app_names
        request.user_id = client_id
        request.token_type = "server"
        request.token_permissions = {
            "read": "read" in decoded_token["permissions"],
            "write": "write" in decoded_token["permissions"],
            "scope": decoded_token.get("scope", "").split()
        }
        request.client_id = client_id

    def _is_authorized_client(self, client_id):
        """V√©rifie si le client est autoris√© (peut √™tre bas√© sur une whitelist)"""
        authorized_clients = getattr(Config, 'AUTHORIZED_SERVER_CLIENTS', [])
        return client_id in authorized_clients

# Instance globale
auth_manager = AuthManager()

# Middleware principal
def authenticate_request():
    return auth_manager.authenticate_request()

# D√©corateurs sp√©cialis√©s
def require_user_token(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if getattr(request, 'token_type', None) != "user":
            return jsonify({"error": "Access denied. User token required."}), 403
        return f(*args, **kwargs)
    return wrapper

def require_api_token(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        token_type = getattr(request, 'token_type', None)
        if token_type not in ["api", "server"]:
            return jsonify({"error": "Access denied. API or Server token required."}), 403
        return f(*args, **kwargs)
    return wrapper

def require_server_token(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if getattr(request, 'token_type', None) != "server":
            return jsonify({"error": "Access denied. Server token required."}), 403
        return f(*args, **kwargs)
    return wrapper

def require_permission(permission):
    """D√©corateur pour v√©rifier des permissions sp√©cifiques"""
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            token_permissions = getattr(request, 'token_permissions', {})

            if permission == "read" and not token_permissions.get("read", False):
                return jsonify({"error": "Read permission required"}), 403
            elif permission == "write" and not token_permissions.get("write", False):
                return jsonify({"error": "Write permission required"}), 403
            elif permission == "admin" and not token_permissions.get("admin", False):
                return jsonify({"error": "Admin permission required"}), 403

            return f(*args, **kwargs)
        return wrapper
    return decorator

def require_valid_app_ids(param_name=None, allow_multiple=True, source="kwargs", permission="read"):
    """
    Version am√©lior√©e avec gestion des permissions
    """
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # V√©rification de base de l'authentification
            auth_result = authenticate_request()
            if auth_result:
                return auth_result

            app_names = getattr(request, 'app_names', None)
            token_permissions = getattr(request, 'token_permissions', {})

            # V√©rification de la permission
            if permission == "write" and not token_permissions.get("write", False):
                return jsonify({"error": "Write permission required for this operation"}), 403

            if app_names:
                # Extraction des app_ids selon la source
                if source == "kwargs":
                    app_ids = kwargs.get(param_name)
                elif source == "args":
                    app_ids = request.args.get(param_name)
                elif source == "json":
                    data = request.get_json(silent=True) or {}
                    app_ids = data.get(param_name)
                else:
                    return abort(400, {"error": f"Invalid source: {source}"})

                if not app_ids:
                    return abort(400, {"error": f"{param_name} is required"})

                # Conversion en liste si multiple autoris√©
                app_id_list = app_ids.split(',') if allow_multiple and isinstance(app_ids, str) else [app_ids]

                # R√©cup√©ration des applications autoris√©es
                valid_apps = Application.query.filter(Application.name.in_(app_names)).all()
                valid_app_ids = [str(app.id) for app in valid_apps]

                # V√©rification des acc√®s
                invalid_app_ids = [app_id for app_id in app_id_list if app_id not in valid_app_ids]

                if invalid_app_ids:
                    return jsonify({
                        "error": f"Unauthorized access to applications",
                        "unauthorized_apps": invalid_app_ids,
                        "authorized_apps": valid_app_ids
                    }), 403

            return f(*args, **kwargs)
        return wrapper
    return decorator
```

## üîë **2. G√©n√©rateur de tokens server-to-server**

```python
# api/auth/token_generator.py
import jwt
from datetime import datetime, timedelta
from config import Config
from api.models import Application, db
import logging

logger = logging.getLogger(__name__)

class ServerTokenGenerator:
    """G√©n√©rateur de tokens JWT pour l'authentification server-to-server"""

    def __init__(self):
        self.secret_key = Config.SECRET_KEY
        self.algorithm = 'HS256'

    def generate_server_token(self, client_id, app_names, permissions=None, expires_in=3600, scope=None):
        """
        G√©n√®re un token JWT pour l'authentification server-to-server

        Args:
            client_id (str): Identifiant unique du client
            app_names (list): Liste des noms d'applications autoris√©es
            permissions (list): Liste des permissions ['read', 'write', 'admin']
            expires_in (int): Dur√©e de validit√© en secondes
            scope (str): Scope OAuth2 optionnel

        Returns:
            str: Token JWT sign√©
        """
        try:
            # Validation des applications
            valid_apps = Application.query.filter(Application.name.in_(app_names)).all()
            if len(valid_apps) != len(app_names):
                invalid_apps = set(app_names) - {app.name for app in valid_apps}
                raise ValueError(f"Invalid applications: {', '.join(invalid_apps)}")

            # Payload du token
            payload = {
                "token_type": "server",
                "client_id": client_id,
                "app_names": app_names,
                "permissions": permissions or ["read"],
                "scope": scope or "api:read",
                "exp": datetime.utcnow() + timedelta(seconds=expires_in),
                "iat": datetime.utcnow()
            }

            # G√©n√©ration du token
            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

            logger.info(f"Generated server token for client {client_id} with apps {app_names}")
            return token

        except Exception as e:
            logger.error(f"Error generating server token: {e}")
            raise

    def verify_server_token(self, token):
        """
        V√©rifie la validit√© d'un token server
        """
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])

            if payload.get("token_type") != "server":
                raise ValueError("Not a server token")

            return payload

        except jwt.ExpiredSignatureError:
            raise ValueError("Token expired")
        except jwt.InvalidTokenError as e:
            raise ValueError(f"Invalid token: {e}")

    def refresh_token(self, token, expires_in=3600):
        """
        Rafra√Æchit un token existant
        """
        try:
            payload = self.verify_server_token(token)

            # R√©g√©n√®re avec les m√™mes param√®tres mais nouvelle expiration
            new_payload = payload.copy()
            new_payload["exp"] = datetime.utcnow() + timedelta(seconds=expires_in)
            new_payload["iat"] = datetime.utcnow()

            return jwt.encode(new_payload, self.secret_key, algorithm=self.algorithm)

        except Exception as e:
            logger.error(f"Error refreshing token: {e}")
            raise

# Instance globale
token_generator = ServerTokenGenerator()
```

## üåê **3. Endpoints pour la gestion des tokens server**

```python
# api/routes/server_auth.py
from flask import Blueprint, request, jsonify, current_app
from api.auth.token_generator import token_generator
from api.auth.middleware import require_server_token, require_permission
from api.models import Application, db
import logging

logger = logging.getLogger(__name__)

server_auth_bp = Blueprint('server_auth', __name__, url_prefix='/api/v1/server-auth')

@server_auth_bp.route('/token', methods=['POST'])
@require_server_token
@require_permission("admin")  # Seuls les tokens avec permission admin peuvent g√©n√©rer des tokens
def generate_server_token():
    """
    Endpoint pour g√©n√©rer de nouveaux tokens server-to-server
    """
    try:
        data = request.get_json()

        # Validation des donn√©es
        required_fields = ['client_id', 'app_names']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400

        client_id = data['client_id']
        app_names = data['app_names']
        permissions = data.get('permissions', ['read'])
        expires_in = data.get('expires_in', 3600)
        scope = data.get('scope', 'api:read')

        # G√©n√©ration du token
        token = token_generator.generate_server_token(
            client_id=client_id,
            app_names=app_names,
            permissions=permissions,
            expires_in=expires_in,
            scope=scope
        )

        return jsonify({
            "access_token": token,
            "token_type": "Bearer",
            "expires_in": expires_in,
            "scope": scope,
            "client_id": client_id,
            "authorized_apps": app_names
        })

    except ValueError as e:
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        logger.error(f"Error generating server token: {e}")
        return jsonify({"error": "Internal server error"}), 500

@server_auth_bp.route('/token/verify', methods=['POST'])
def verify_token():
    """
    Endpoint pour v√©rifier la validit√© d'un token
    """
    try:
        data = request.get_json()
        token = data.get('token')

        if not token:
            return jsonify({"error": "Token is required"}), 400

        payload = token_generator.verify_server_token(token)

        return jsonify({
            "valid": True,
            "client_id": payload.get("client_id"),
            "app_names": payload.get("app_names"),
            "permissions": payload.get("permissions"),
            "expires_at": payload.get("exp")
        })

    except ValueError as e:
        return jsonify({"valid": False, "error": str(e)}), 400
    except Exception as e:
        logger.error(f"Error verifying token: {e}")
        return jsonify({"error": "Internal server error"}), 500

@server_auth_bp.route('/applications', methods=['GET'])
@require_server_token
@require_permission("read")
def list_authorized_applications():
    """
    Endpoint pour lister les applications accessibles par le token
    """
    try:
        app_names = getattr(request, 'app_names', [])

        applications = Application.query.filter(Application.name.in_(app_names)).all()

        app_list = [{
            "id": app.id,
            "name": app.name,
            "description": app.description,
            "created_at": app.created_at.isoformat() if app.created_at else None
        } for app in applications]

        return jsonify({
            "applications": app_list,
            "count": len(app_list)
        })

    except Exception as e:
        logger.error(f"Error listing applications: {e}")
        return jsonify({"error": "Internal server error"}), 500
```

## ‚öôÔ∏è **4. Configuration pour Apigee**

```python
# config.py - Ajouts pour l'authentification server
class Config:
    # ... configuration existante ...

    # Authentification server-to-server
    AUTHORIZED_SERVER_CLIENTS = [
        "apigee-gateway",
        "internal-service-1",
        "data-processor",
        "reporting-service"
    ]

    # Dur√©es de validit√© des tokens (en secondes)
    SERVER_TOKEN_EXPIRY = 3600  # 1 heure
    SERVER_TOKEN_REFRESH_BUFFER = 300  # 5 minutes pour le rafra√Æchissement

    # Permissions par d√©faut
    DEFAULT_SERVER_PERMISSIONS = ["read"]
```

## üõ°Ô∏è **5. Exemples d'utilisation dans les routes**

```python
# Exemples d'utilisation des d√©corateurs

# Route accessible uniquement par les tokens server avec permission read
@bp.route('/api/data/<app_id>', methods=['GET'])
@require_server_token
@require_permission("read")
@require_valid_app_ids(param_name='app_id', source='kwargs', permission='read')
def get_application_data(app_id):
    """R√©cup√®re les donn√©es d'une application sp√©cifique"""
    # Seuls les tokens server avec acc√®s √† cette app_id peuvent acc√©der
    app = Application.query.get_or_404(app_id)
    return jsonify({"data": "sensitive_data", "app": app.name})

# Route accessible par tous les tokens avec permission write
@bp.route('/api/data/<app_id>', methods=['POST'])
@require_api_token  # Accepte √† la fois les tokens API et Server
@require_permission("write")
@require_valid_app_ids(param_name='app_id', source='kwargs', permission='write')
def update_application_data(app_id):
    """Met √† jour les donn√©es d'une application"""
    data = request.get_json()
    # Logique de mise √† jour...
    return jsonify({"status": "updated", "app_id": app_id})

# Route accessible uniquement par les tokens server admin
@bp.route('/api/admin/operations', methods=['POST'])
@require_server_token
@require_permission("admin")
def admin_operation():
    """Op√©ration d'administration r√©serv√©e aux serveurs"""
    data = request.get_json()
    # Logique admin...
    return jsonify({"status": "admin_operation_completed"})
```

## üìã **6. Structure des tokens JWT**

### Token Server typique :
```json
{
  "token_type": "server",
  "client_id": "apigee-gateway",
  "app_names": ["app1", "app2", "app3"],
  "permissions": ["read", "write"],
  "scope": "api:read api:write",
  "exp": 1735689600,
  "iat": 1735686000
}
```

### Token API existant (r√©trocompatible) :
```json
{
  "token_type": "api",
  "app_names": ["app1"],
  "token_name": "mon-token-api",
  "exp": 1735689600
}
```

### Token Utilisateur :
```json
{
  "sub": "user123",
  "exp": 1735689600
}
```

## üöÄ **7. Utilisation avec Apigee**

Pour Apigee, vous pouvez maintenant :

1. **G√©n√©rer des tokens** via l'endpoint `/api/v1/server-auth/token`
2. **V√©rifier les tokens** via `/api/v1/server-auth/token/verify`
3. **Utiliser les tokens** dans les headers Authorization
4. **Contr√¥ler finement les acc√®s** par application et permission

Cette solution offre :
- ‚úÖ **R√©trocompatibilit√©** avec votre syst√®me existant
- ‚úÖ **S√©curit√© renforc√©e** avec diff√©rents types de tokens
- ‚úÖ **Contr√¥le d'acc√®s granulaire** par application et permission
- ‚úÖ **Gestion centralis√©e** de l'authentification
- ‚úÖ **Int√©gration Apigee** optimale
- ‚úÖ **Logs et monitoring** complets













Excellente d√©cision üî• ‚Äî passer √† un identifiant **`app_uuid`** est la bonne approche pour s√©curiser et stabiliser ton syst√®me d‚Äôauthentification (et √©viter que les renommages d‚Äôapplications ne cassent les tokens).

Voici une version **am√©lior√©e et modernis√©e** de ton `middleware.py`, enti√®rement compatible avec les UUID et pr√™te pour la production.
Je t‚Äôexplique d‚Äôabord les changements cl√©s, puis je te donne le code complet pr√™t √† copier.

---

## ‚öôÔ∏è **Principaux changements apport√©s**

| Type d‚Äôam√©lioration                | Description                                                                                                   |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| ‚úÖ **Migration vers `app_uuid`**    | Remplacement complet de `app_names` par `app_uuids` (identifiant immuable)                                    |
| ‚úÖ **R√©trocompatibilit√©**           | Si un token plus ancien contient `app_names`, le syst√®me mappe automatiquement vers les `uuid` correspondants |
| ‚úÖ **V√©rification robuste**         | Les acc√®s sont v√©rifi√©s en base via `Application.uuid`, pas `name`                                            |
| ‚úÖ **Clart√© du code**               | Regroupement des fonctions, factorisation des v√©rifications et logs plus pr√©cis                               |
| ‚úÖ **Pr√©paration Apigee**           | Compatible avec des tokens server-to-server sign√©s par Apigee contenant `app_uuid` et `client_id`             |
| ‚úÖ **Messages d‚Äôerreur explicites** | Toutes les erreurs retournent un JSON clair et logu√©                                                          |

---

## üß© **Code complet `api/auth/middleware.py`**

```python
import jwt
import logging
from flask import request, jsonify, abort
from functools import wraps
from api.models import Application, APIToken
from config import Config

logger = logging.getLogger(__name__)


class AuthManager:
    """Central authentication manager for user, API, and server tokens."""

    def __init__(self):
        self.token_types = {
            'user': self._validate_user_token,
            'api': self._validate_api_token,
            'server': self._validate_server_token
        }

    def authenticate_request(self):
        """Main middleware handling all token types."""
        if request.method == 'OPTIONS':
            return

        try:
            auth_header = request.headers.get('Authorization')
            if not auth_header:
                return jsonify({"error": "Authorization header required"}), 401

            token = self._extract_token(auth_header)
            if not token:
                return jsonify({"error": "Invalid authorization format"}), 401

            decoded_token = self._decode_token(token)
            token_type = self._identify_token_type(decoded_token)

            validation_method = self.token_types.get(token_type)
            if not validation_method:
                return jsonify({"error": f"Unsupported token type: {token_type}"}), 401

            return validation_method(token, decoded_token)

        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return jsonify({"error": "Authentication failed", "details": str(e)}), 401

    # ------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------

    def _extract_token(self, auth_header):
        """Extracts Bearer or raw token from header."""
        parts = auth_header.split()
        if len(parts) == 2 and parts[0].lower() == 'bearer':
            return parts[1]
        elif len(parts) == 1:
            return parts[0]
        return None

    def _decode_token(self, token):
        """Decode a JWT using the configured secret key."""
        try:
            return jwt.decode(token, Config.SECRET_KEY, algorithms=['HS256'], options={"verify_exp": True})
        except jwt.ExpiredSignatureError:
            raise Exception("Token expired")
        except jwt.InvalidTokenError as e:
            raise Exception(f"Invalid token: {e}")

    def _identify_token_type(self, decoded_token):
        """Determine token type based on its payload content."""
        if "token_type" in decoded_token:
            return decoded_token.get("token_type")
        elif "sub" in decoded_token:
            return "user"
        else:
            raise Exception("Unknown token type")

    # ------------------------------------------------------------
    # Token Validators
    # ------------------------------------------------------------

    def _validate_user_token(self, token, decoded_token):
        """Validate standard user tokens."""
        request.user_id = decoded_token["sub"]
        request.app_uuids = None
        request.token_type = "user"
        request.token_permissions = {"read": True, "write": True}
        logger.debug(f"User token validated for user_id={request.user_id}")

    def _validate_api_token(self, token, decoded_token):
        """Validate internal API tokens."""
        token_entry = APIToken.query.filter_by(token=token).first()
        if not token_entry or not token_entry.is_active:
            raise Exception("API token revoked or invalid")

        app_uuids = decoded_token.get("app_uuids")
        if not app_uuids and decoded_token.get("app_names"):
            # r√©trocompatibilit√©
            app_uuids = [
                app.uuid for app in Application.query.filter(
                    Application.name.in_(decoded_token["app_names"])
                ).all()
            ]

        request.app_uuids = app_uuids
        request.user_id = decoded_token.get("token_name")
        request.token_type = "api"
        request.token_permissions = getattr(token_entry, 'permissions', {"read": True, "write": False})
        logger.debug(f"API token validated for user={request.user_id}, apps={app_uuids}")

    def _validate_server_token(self, token, decoded_token):
        """Validate server-to-server tokens (Apigee, internal services)."""
        required_fields = ["client_id", "permissions"]
        for field in required_fields:
            if field not in decoded_token:
                raise Exception(f"Missing required field: {field}")

        client_id = decoded_token["client_id"]
        if not self._is_authorized_client(client_id):
            raise Exception(f"Unauthorized client: {client_id}")

        app_uuids = decoded_token.get("app_uuids")
        if not app_uuids:
            raise Exception("Missing 'app_uuids' in token")

        valid_apps = Application.query.filter(Application.uuid.in_(app_uuids)).all()
        if len(valid_apps) != len(app_uuids):
            invalid = set(app_uuids) - {a.uuid for a in valid_apps}
            raise Exception(f"Invalid application UUIDs: {', '.join(invalid)}")

        # Store in request context
        request.app_uuids = app_uuids
        request.user_id = client_id
        request.client_id = client_id
        request.token_type = "server"
        request.token_permissions = {
            "read": "read" in decoded_token["permissions"],
            "write": "write" in decoded_token["permissions"],
            "admin": "admin" in decoded_token["permissions"],
            "scope": decoded_token.get("scope", "").split()
        }
        logger.debug(f"Server token validated for client={client_id}, apps={app_uuids}")

    def _is_authorized_client(self, client_id):
        """Check if the client is authorized based on config whitelist."""
        authorized_clients = getattr(Config, 'AUTHORIZED_SERVER_CLIENTS', [])
        return client_id in authorized_clients


# ------------------------------------------------------------
# Global instance and decorators
# ------------------------------------------------------------

auth_manager = AuthManager()


def authenticate_request():
    return auth_manager.authenticate_request()


def require_user_token(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if getattr(request, 'token_type', None) != "user":
            return jsonify({"error": "Access denied. User token required."}), 403
        return f(*args, **kwargs)
    return wrapper


def require_api_token(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        token_type = getattr(request, 'token_type', None)
        if token_type not in ["api", "server"]:
            return jsonify({"error": "Access denied. API or Server token required."}), 403
        return f(*args, **kwargs)
    return wrapper


def require_server_token(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if getattr(request, 'token_type', None) != "server":
            return jsonify({"error": "Access denied. Server token required."}), 403
        return f(*args, **kwargs)
    return wrapper


def require_permission(permission):
    """Decorator to check specific permissions like read/write/admin."""
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            perms = getattr(request, 'token_permissions', {})
            if not perms.get(permission, False):
                return jsonify({"error": f"{permission.capitalize()} permission required"}), 403
            return f(*args, **kwargs)
        return wrapper
    return decorator


def require_valid_app_uuids(param_name=None, allow_multiple=True, source="kwargs", permission="read"):
    """Check that the app UUID(s) in request match authorized ones."""
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            auth_result = authenticate_request()
            if auth_result:
                return auth_result

            app_uuids = getattr(request, 'app_uuids', None)
            perms = getattr(request, 'token_permissions', {})

            if permission == "write" and not perms.get("write", False):
                return jsonify({"error": "Write permission required for this operation"}), 403

            if app_uuids:
                if source == "kwargs":
                    param_value = kwargs.get(param_name)
                elif source == "args":
                    param_value = request.args.get(param_name)
                elif source == "json":
                    data = request.get_json(silent=True) or {}
                    param_value = data.get(param_name)
                else:
                    return abort(400, {"error": f"Invalid source: {source}"})

                if not param_value:
                    return abort(400, {"error": f"{param_name} is required"})

                param_list = param_value.split(',') if allow_multiple and isinstance(param_value, str) else [param_value]

                invalid = [pid for pid in param_list if pid not in app_uuids]
                if invalid:
                    return jsonify({
                        "error": "Unauthorized access to applications",
                        "unauthorized_apps": invalid,
                        "authorized_apps": app_uuids
                    }), 403

            return f(*args, **kwargs)
        return wrapper
    return decorator
```

---

## üß† **R√©sum√© des avantages**

| Cat√©gorie        | D√©tail                                                                  |
| ---------------- | ----------------------------------------------------------------------- |
| üîí S√©curit√©      | Validation par UUID immuable                                            |
| üß© Compatibilit√© | Support automatique pour anciens tokens (`app_names`)                   |
| üß∞ Maintenance   | Code clair, factoris√© et compatible Apigee                              |
| üîÑ Extensibilit√© | Ajout facile de nouveaux types de tokens (`internal`, `external`, etc.) |
| ü™∂ L√©g√®ret√©      | Aucune d√©pendance suppl√©mentaire, tout est g√©r√© dans le middleware      |

---

Souhaites-tu que je t‚Äôajoute le **mod√®le SQLAlchemy mis √† jour (`Application`)** et la **migration Alembic** correspondante pour inclure `uuid` + mise √† jour automatique des anciennes donn√©es (`app.name ‚Üí app.uuid` dans la base) ?
Ainsi, ton middleware et ta base seraient totalement synchronis√©s.
